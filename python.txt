==== установка дополнительных модулей ==
 sudo apt-get install python3-tk python-tk -y

========================================
==== сервер ====
python3 -m http.server 
		--cgi
 /cgi-bin/
	если ошибка
 lsof -i :8000
 kill -9 PID


  ---- на сервере 
 1. Сделать файл исполняемым
 2. ->
#!/usr/bin/python3.5
import cgi 

form = cgi.FieldStorage()
print('Content-type: text/html\n')
print(' <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">')
print('<title>Reply Page</title>')
print('<body>')
if not 'user' in form:
    print('<h1>Кто ты?</h1>')
else:
    print('<h1>Привет <i>%s</i>!</h1>' % cgi.escape(form['user'].value))

print('</body>')
================
 

print()
user = input()
print( lang , 'Is' , 'Fun' , sep = ' * ' , end = '!\n' )

==== ошибки ====================
---- Синтаксическая
---- Исполнения (неопределенная переменная)
---- Логическая 
================================
==== Операторы =================
 // 	- целочисленное деление
 %	- деление по модулю (остаток)
 **	- возвеление в степень

 ==== приоритет ====

 **	Возведение в степень

 +	Положительное значение
 - 	Отрицательное значение
 ~	Побитовое отрицание

 *	Умножение
 /	Деление
 //	Целочисленное деление
 %	Деление по модулю (остаток)

 +	Сложение
 -	Вычитание
 
 |	Побитовое ИЛИ

 ^	Побитовое исключающее ИЛИ
 &	Побитовое И
 >>	Побитовый сдвиг вправо
 <<	Побитовый сдвиг влево

 >, < =, <, < =, = =, !=	 Сравнение
 =, %=, /=, //=, -=, +=, *=, **= Присваивание

 is, is not			 Идентичность
 in, not in			 Вхождение

 not	Логическое отрицание
 and	Логическое И
 or	Логическое ИЛИ

 ================================
 
 ---- присваивание значений
  += 	Сложение значений правого операнда к левому
  -= 	Вычитание значения правого операнда от левого
  *= 	Умножение правого и левого операндов
  /= 	Делит левый операнд на правый
  %= 	Делит по модулю левый операнд на правый
  //= 	Делит нацело по модулю левый операнд на правый
  **= 	Возводит в левый операнд в степень правого

 --------------------------

 bin(x)		- Посмотреть бинарный код числа

 ---- преобразование типов
 int(x)		- Преобразует х в целое число
 float(x)	- Преобразует х в число с плавающей точкой
 str(x)		- Преобразует х в строковое представление
 chr(x)		- Преобразует целое х в символ
 unichr(x)- Преобразует целое х в символ Юникода (Unicode)
 ord(x)		- Преобразует символ х в соответствующее ему целое число
 hex(x)		- Преобразует целое х в шестнадцатеричную строку
 oct(x)		- Преобразует целое х в восьмеричную строку

 complex(x)	- преобразует в комплексное число: 5 -> (5+0j)

 set(x)			- в множество
 frozenset(x)	- в неизменяемое множество
 
 tuple(arr)		- в кортеж
 

  type() 	- определяет, к какому типу данных принадлежит
		  указанная переменная

 ---- побитовые операции
 |	ИЛИ			1010 | 0101 = 1111 (0|0=0 1|1=1 0|1=1)
 &	И			1010 & 1100 = 1000 (0&0-0 1&1=1 0&1=0)
 ~	НЕ			1010 ~ 0011 = 0100 (0~0=1 1~1=0 0~1=0)
 ^	Исключающее ИЛИ		1010 ^ 0100 = 1110 (0^0=0 1^1=0 0^1=1)
 <<	Сдвиг влево		0010 << 2 = 1000
 >>	Сдвиг вправо		1000 >> 2 = 0010

 ==== работа с числами
 abs(a)		- модуль числа	
 divmod(a,b)	- просмотр результата целоч.деления и остатка
 pow(a,b)	- возведение в степень
 round(a)	- округление	0.5 вниз

 
 x.as_integer_ratio() - показывает какие два числа надо разделить, 
			чтобы получить результат x
			// x=0.5	-> (1,2)
 x.is_integer()		// x=0.5	-> False


 is 	- в простых конструкциях как ==
		  34 is 56	-> false

 ---- ---- комплексные числа
 b = 5+5j	- j определяется, как мнимая еденица
 c = complex(5,5)
 
 c.imag		- вещественная часть
 c.real		- действительная

 ---- математические операции
 ---- ---- из модулей 	import math, random

 math.ceil()	- округление вверх	
 math.floor()	- 			 вниз

 math.pow(a,b)
 math.sqrt(a)

 math.sin()
 math.cosin()
 math.tan()

 math.pi	-> 3.141592653589793
 math.e		-> 2.718281828459045

 random.random()	  -> 0 ... 1.0
 random.randint(0,10)	  -> 7
 random.randrange(0,10,5) #начальное, конечное, шаг -> 0
 random.random()	  -> 0.8815129820148103
 random.choice('asdddff') -> 'd’
 random.sample(последовательность, размер)	
					  - генерирует список элементов, 
					    случайно выбранных из последовательности
  random.shuffle(arr)	   - перетасовка 

 ---- десятичные дроби
 item = 0.70			-> 0.699999.
 print( 'Item:\t' , '%.20f' % item )

 ---- для более точных расчетов 
  from decimal import *
  item = Decimal(0.70)


 ==============================
 ==== дополнительные св-ва
 some.__sizeof()__	- размер в памяти
 ====
 ==== строки
 
 '''text'''	- тройные кавычки нужны для объемного текста, описания модуля
 def.__doc__	- обращение к документации функции def

 ---- доступ к символам строки
 a = 'hello world'
	a[0]	-> h
	a[-1]	-> d
	
	строки неизменяемы
	a[0] = H	-> Error

	срезы - slice
	a[0:5]	-> hello
	a[:]	-> вся строка
	a[::2]	-> вся строка с шагом 2
	a[::-1]	-> разворот строки

 ---- операции со строками: 
  +
  *num
  in			- 'wo' in 'word'	-> true
  not in
 

 ---- сырые строки  r/R - подавление экранирующей последовательности	
  a = r'Hello \n world'		// \n экранируется -> \\n

 ---- unicode строки
  a = u'Unicode'

 ---- разбиение строки - split
 a = 'hello word'
 a.split()			- 	  - 	по словам 	-> ['hello', 'word']
 a.split('o')		-     -     по букве О	-> ['hell', ' w', 'rd']
 ---- соединение строки join (аналогично split)
 'o'.join(a)

 ---- модификация строк

 .capitalize()		- Переводит первый символ строки в верхний регистр, а все
			  остальные — в нижний
 .title( )		- Переводит первую букву каждого слова в верхний регистр,
			  а все остальные — в нижний
 .upper()	-| регистры
 .lower()	 |
 .swapcase( )	 | -> смена регистра
 .join( seq )	- Сборка строки из списка seq с добавлением разделителя
 .lstrip( )	-| Удаление () пробелов ( (@#) символов) в начале строки
 .rstrip( )	 | 		     			 в конце строки
 .strip( )	 |		     			 в начале и конце
 .replace(old,new)- Замена всех подстрок old на подстроку new
 .ljust(w, c)	-| Подгоняет строку под ширину в w символов, добавляя справа символы c
 .rjust(w, c)	 |						      слева 
 .center(w, c)	- Центрирует строку, подгоняя под ширину в w символов, добавляя
		  справа и слева символы c (по умолчанию добавляется пробел)
 .count( sub )	- Возвращает количество вхождений подстроки sub
 .find( sub )	- Возвращает номер первого вхождения подстроки sub или –1
 .rfind()	- поиск назад, последнего вхождения

 .startswith(sub) -| True - если подстрока sub найдена в начале строки
 .endswith(sub)	   | 				      в конце строки

 .isalpha( )	-| True - если все символы строки являются только буквами
 .isnumeric( )	 |					   только цифрами
 .isalnum( )	 | только буквами или цифрами ( + если есть пробел -> False)

 .islower( )	-| True - если все символы строки в нижнем регистре
 .isupper( )	 |				  в верхнем регистре
 .istitle( )	 |	все первые буквы слов в верхнем регистре

 .isspace( )	- True - если строка пустая (то есть в ней содержатся пробелы, 
		  символы табуляции, символы новой строки)

 .isdigit( )	-| True, если строка содержит только цифры
 .isdecimal( )	 | 			      десятичные числа

 ---- изменение строки .replace()
 str.replace('from', 'to')

 ---- постановочные символы

 %s, 		-  "Hello %s %s" %("one", "two")	-> 'Hello one two'
 {}		-  '{} students'.format(26)		-> '26 students'
		   '{1} and {0}'.format( 'Burger' , 'Fries')

 '%d', '%i', '%u' Десятичное число
 '%o' 		  Число в восьмеричной системе счисления
 '%x', '%X' 	  Число в шестнадцатеричной системе счисления
 '%e', '%E' 	  Число с плавающей точкой с экспонентой
 '%f', '%F' 	  Число с плавающей точкой
 '%g', '%G' 	  Число с плавающей точкой. с экспонентой, если она меньше,
		  чем -4 или точности, в противном случае - обычный формат
 '%c' 		  Символ (строка из одного символа или код символа)
 '%r' 		  Сырая строка
 '%s' 		  Строка
 '%%' 		  '%'

 ---- ---- Флаги преобразования строк

 "0" Свободное место будет заполнено нулями.
 "-" Свободное место будет заполнено пробелами справа
 "+" Свободное место будет заполнено пробелами слева

  a='hello python'

 '%.5s'%a		-> 'hello'
 '%2.f'%5.111111	-> ' 5'
 '%.2f'%5.111111	-> '5.11'
 '%2.3f'%5.111111	-> '5.111'
 '%.*s'%(3,a)		-> 'hel'
 '%-10d'%5.111111	-> '5 '
 '%+10d'%5.111111	-> ' +5'

 ---- ---- Возможности format

 	нумеровать аргументы:
 'hello {0} {1} {1} {0}' .format('student','Vasya')
 -> 'hello studentVasyaVasya student'

 	указывать имена переменных:
 'hello {a} {b} {a} {b}' .format(a='student',b='Vasya')
 -> 'hello studentVasya studentVasya'

	резервировать число знаков:
 'hello {a:17} {b} {a} {b}' .format(a='student',b='Vasya')
 -> 'hello student Vasya studentVasya'

 'hello {a:>17} {b} {a} {b}' .format(a='student',b='Vasya')
 -> 'hello studentVasya studentVasya’

 aa=(3,5)
 'a:{0[1]};b:{0[1]}'.format(aa)	-> 'a:5;b:5'

 '{:<10}'.format('a')		-> 'a '
 '{:>10}'.format('a')		-> ' a'

 '{:^10}'.format('a')		-> ' a '
 '{:+^10}'.format('a')		-> '++++a+++++'
 '{:*^10}'.format('a')		-> '****a*****'

 a=33.333333333
 '{:.2%}'.format(a)		-> '33.33%'
 '{:2%}'.format(a)		-> '33.333333%'
 '{:2.2%}'.format(a)		-> '33.33%'

 '{}{}{}'.format(1,2,3)		-> '123'

 a=5, b=3, c=1
 '{}{}{}'.format(a,b,c)		-> '531'
 '{1}{1}{1}'.format(a,b,c)	-> '333’

 	Возможность использования сложных структур данных

  words= ('Vasya', 'student')
  "Hello {} {}".format(*words)			-> 'Hello Vasya student'


 words= {'name':'Vasya', 'work':'student'}
 " Hello {first} {last}".format(**words)	
	->  'Hello Vasya student'
 "Good {0} {first} {last}".format('morning', **words)
	 -> 'Good morning Vasya student'


	Использование префиксов систем счисления
 '{:b}'.format(0b11)	-> '11'
 '{:#b}'.format(0b11)	-> '0b11’

	красивый вывод
 '{}'.format(1234567890)	-> '1234567890'
 '{:,}'.format(1234567890)	-> '1,234,567,890'
 '{:05d}'.format(5)		-> '00005'
 '9'.zfill(5) 			-> '00009’
 ---- 
 dir(mod)	- I. получения имен всех функций и переменных, определенных в модуле
		- II.Возвращает имена [переменных], доступные в локальной
			  области, либо атрибуты указанного объекта в алфавитном
			  порядке.
		
		|for i in dir(mod)
		|	print(i)

 Модуль __builtins__ содержит функции и переменные, которые доступны
 по умолчанию, например, функцию print().

 ---- преобразование строк

 .encode() 	- Для преобразования символов в кодировку Unicode 
 .decode()	  обратно

 import unicodedata	 |
 unicodedata.name()	-| имя каждого символа в формате Unicode

 ---- ---- префиксы
 b	- байтовый литерал
	 b'Gr\xc3\xb6n'.decode('utf-8')			-> Grön

 \N{}   - Unicode-имя 
	 'Gr\N{LATIN SMALL LETTER O WITH DIAERESIS}n'	-> Grön

================================

 ---- работа со списками (массивами) (LIST)
 .append(x)		- Добавляет элемент х в конец списка
			| a=[1,2,3,4,5]
			| a.append(['c','d',4])
			-> a = [1,2,3,4,5, ['c','d',4]]
 .extend(L)		- Добавляет все элементы списка L в конец списка
			| a=[1,2,3,4,5]
			| a.extend(['c','d',4])
			-> a = [1,2,3,4,5, 'c', 'd', 4]
 .insert(i,x)	- Вставляет элемент x в позицию перед индексом i в списке
 
 .remove(x)		- Удаляет первый элемент х из списка
 .pop(i)		- Удаляет элемент с индексом i и возвращает его
 .pop()			- удаляет последний добавленный элемент
 del(i)		- удалить i-ый элемент списка
 del arr[i]
 
 .index(x)		- Возвращает индекс первого элемента х в списке
 index in arr		- [boorlean]

 .count(x)		- Возвращает количество вхождений элемента x в список
 .sort()		- Сортирует элементы списка по возрастанию
		  возвращает отсортированный список,
			сначала числовые значения, а затем строковые,
			например 1, 2, 3, A, B, C.
  sorted(arr) 		- без изменения самого массива

 .reverse(arr)		- Обращает порядок следования элементов
 list(reversed(arr))	- ?без изменения самого массива

 len(L)		- возвращающает размер списка L
 int(s)		- возвращает числовое представление строковой величины s.

 	
 
 del(i1:i5)	- удалить диапазон i1:i5 (исключая i5)

 ---- массивы
 max(arr)
 min(arr)
 sum(arr)

 arr.reverse()

 arr1 = arr2 	// ссылаются на одну ячейку памяти

 arr.index(i)	- поиск elem по индексу
 elem in arr	- true/false

 ---- ---- преобразование в список
 list(str)			- разбивает по буквам	->['h', 'e', ... ]
 ---- ---- преобразование елементов массива
 arr = ['1','2']
 map(int, a)		- в версии 2	-> [1,2]
 list(map(int,a))	- в версии 3	-> [1,2]

| def f(x): return x*x
| arr=[1, 5, 6]
| list(map(f, arr))	-> [1, 25, 36]


 ---- кортеж (TUPLE)  — это неизменяемый список, элементы которого можно
		присвоить отдельным переменным с помощью так
		называемой распаковки последовательности.
		
		можно обращаться, используя имя кортежа и номер индекса
		в квадратных скобках.

 tuple = ( 'Red' , 'Green' , 'Red' , 'Blue' , 'Red' )
 a , b , c , d , e = tuple	// распаковка

 a = tuple()	-> ()
 a = ()		-> ()

 ---- ---- преобразование в кортеж
 tuple()

 ---- множество (набор) (SET)- I. это упорядоченный набор уникальных элементов,
		  	значения которых могут быть обработаны с помощью методов. 
			II. - это неповторяемые наборы значений.
 				set={1,2,3,5,1,1,2,2,3,3,3} -> set={1,2,3,5}


		  нельзя обращаться по индексу элемента
	
 set = { 'Alpha' , 'Bravo' , 'Charlie' }

 a = set()			-> set()
 a = set('hello')		-> {'h', 'o', 'l', 'e'}
 a = {'a', 'b', 'c', 'd'}	-> {'b', 'c', 'a', 'd'}
	# генератор множеств
 a = {i ** 2 for i in range(10)}-> {0, 1, 4, 81, 64, 9, 16, 49, 25, 36}


 a = {}  # А так нельзя!	-> type(a) -> <class 'dict'>
 
 ---- методы
 len(s) 		- число элементов в множестве (размер множества).
 x in s 		- принадлежит ли x множеству s.
 set.isdisjoint(other) 	- истина, если set и other не имеют общих элементов.
 set == other 		- все элементы set принадлежат other,
			  все элементы other принадлежат set.

 set.issubset(other) 	-|все элементы set принадлежат other.
 set <= other 		 |
 set.issuperset(other) 	 |
 set >= other 		 |

 set.union(other, ...)  -|объединение нескольких множеств.
 set | other | ...	 |

 set.intersection(other, ...)  	-|пересечение.
 set & other & ...		 |Возвращает элементы, принадлежащие обоим множествам

 set.difference(other, ...)		-|множество из всех элементов set, 
 set - other symmetric_difference- ...	 |не принадлежащие ни одному из other.
 set1.difference(set2)			 |Возвращает элемента из множества set1,
					 |которых нет в set2

 set.(other);	-|множество из элементов, встречающихся в одном множестве,
 set ^ other 	 |но не встречающиеся в обоих.

 set.copy() 		- копия множества.

 ---- методы изменяющие множество:

 set.update(other, ...);-|объединение.
 set |= other | ...	 |

 set.intersection_update(other, ...); 	-|пересечение.
 set &= other & ...			 |

 set.difference_update(other, ...);  	-| вычитание.
 set -= other | ...			 |

 set.symmetric_difference_update(other);-|множество из элементов, встречающихся в одном
 set ^= other				 |множестве, но не встречающиеся в обоих.

 set.add(elem) 		- добавляет элемент в множество.
 set.remove(elem) 	- удаляет элемент из множества.
			  KeyError, если такого элемента не существует.
? set.discard(elem) 	- удаляет элемент, если он находится в множестве.
? set.discard( i )	- Удаляет из множества элемент с порядковым номером i
 set.pop() 		- удаляет первый элемент из множества. 
			  Так как множества не упорядочены, нельзя точно сказать,
			  какой элемент будет первым.
 			- Удаляет один элемент из множества случайным образом
 set.clear() 		- очистка множества.


 set.update(x,y,z)	- Добавляет несколько элементов в множество
 
 ---- ---- преобразование в множество
 set(arr)
 frozenset(arr)		- неизменяемое множество (типа кортеж)

 ---- словарь (DICT) - представляет собой список пар ключ:значение,
		 в которых каждый ключ должен быть уникален.
 d = {}
 dict = { 'name' : 'Bob' , 'ref' : 'Python' , 'sys' : ''Win' }

 d = dict(short='dict', long='dictionary')	-> {'short': 'dict', 'long': 'dictionary'}
 d = dict([(1, 1), (2, 4)])			-> {1: 1, 2: 4}

 d = dict.fromkeys(['a', 'b'])			-> {'a': None, 'b': None}
 d = dict.fromkeys(['a', 'b'], 100)		-> {'a': 100, 'b': 100}

 d = {a: a ** 2 for a in range(7)}		-> {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36}
 ---- 
 dict.items()		- вывести пары ключ:значение
 dict.keys()		- вывести все ключи
 dict.values()		- вывести все значения

 del dict['i']		- удалить i-ый элемент
 'name' in dict		- поиск ключа name в arr

 dict.update({'key':val})	- добавление в словарь

 ---- ---- вывести key:val в цикле
    |for key,values in dict.items:
	|	print(key, values)

 ---- ---- range(от, до, шаг) - генерирует последовательность чисел
	   range(3)		# 0, 1, 2
	   range(3, 5)		# 3, 4
	   range(1, 14, 4)	# 1, 5, 9, 13 	// c шагом

 ---- ---- enumerate()	- вывести индекс:значения
 ---- ---- items() 	- вывести пары ключ:значение
 ---- ---- map()	- применение операций ко всем элементам списка
 str1 = '1 2 3 4 5'
 list1 = str.split()	-> list = ['1', '2', '3', '4', '5']

 map1 = map(int, list1) -> <map object at 0x10213a9e8>
 map2 = list(map1)	-> map2 = [1, 2, 3, 4, 5]

 ---- ---- zip()	- обход нескольких списков одновременно
 a=[1,2,3], b=[4,5,6]
 
 zip(a,b)		-> <zip object at 0x1021e13c8>
 z = list(zip(a,b))	-> z = [(1, 4), (2, 5), (3, 6)]

 ---- ---- обход элементов массива
	for i in l1:
	for i in enumerate( l1 ):
	for i in zip( l1, l2 ):
		print( i )

	for key, value in dict.items():
    		print( key, ' = ', value)

 ---- Методы словарей
 d.clear() 		- очищает словарь.
 d.copy() 		- возвращает копию словаря.

 classmethod dict.fromkeys(seq[, value]) - создает словарь с ключами из seq 
					   и значением value (по умолчанию None).

 dict.get(key[, default]) 	- возвращает значение ключа, но если его нет, 
				  не бросает исключение,
				  а возвращает default (по умолчанию None).

 d.items() 		- возвращает пары (ключ, значение).
 d.keys() 		- возвращает ключи в словаре.
 d.pop(key[, default]) 	- удаляет ключ и возвращает значение. 
			  Если ключа нет, возвращает default (по умолчанию бросает исключение).

 d.popitem() 		- удаляет и возвращает пару (ключ, значение). 
			  Если словарь пуст, бросает исключение KeyError. 
			  Помните, что словари неупорядочены.

 d.setdefault(key[, default]) 	- возвращает значение ключа, но если его нет, 
				  не бросает исключение, 
				  а создает ключ с значением default (по умолчанию None).

 d.values() 		- возвращает значения в словаре.

 ==== управляющие конструкции (усл.операторы, циклы)

 ---- if-elif-else

 if num > 5:
    print( 'Number > 5 ')
 elif num < 5:
    print( 'Number < 5 ')
 else:
    print( 'Number = 5 ') 

 ---- ---- в одну строчку
 действие1 if условие else действие2

 aa=10 if '0' in a else 100

 c = a if ( a < b ) else b	// если a < b, то c = a, иначе  c = b

 ------------------------

 ---- while	(на примере чисел фибоначи)
 a = 0
 b = 1
 while b < 100:
     print( b )
     a = b
     b = a + b

 ---- for
 |	a = list(range(0,10))
 |
 |	for j in a:
 |	 	print(j)
 
 ---- ---- генераторы 
 a=[0 for x in range(3)]	-> a=[0, 0, 0]

    дей-е 	цикл-генератор		условие
 a=[x*x 	for x in range(10) if x%2==0]
 
 ---- ---- ---- дву-мерная матрица
 a=[[j for j in range(3)] for i in range(5)]

 -> [[0, 1, 2], [0, 1, 2], [0, 1, 2], [0, 1, 2], [0, 1, 2]]


 ---- ---- for in
 ---- ---- прерывание 		break
 ---- ---- пропуск итерации 	continue
	for i in range(1, 4):
	    for j in range(1, 4):
		
		if i == 1 and j == 1: 
	            print( 'Пропуск')
	            continue

	        if i == 2 and j == 2: 
	            print( 'Прерывание')
	            break
	        print( 'Запуск i = ', i, 'j = ', j)

 ==== with ... as
 with 	- для группировки в блок инструкций, работающих с файлом
 
 | with open( 'update.txt' , 'r+' ) as file :
 |	text = file.read()
 |	print( '\nString:' , text )

 
=========================================

================================
==== функции ==== def
 ---- область видимости
	global
	nonlocal
 ----
 isdigit()	- проверка на число 	# num.isdigit()

 ---- анонимная функция: lambda

 def square(x, y=2):
	return x ** y

 square = lambda x: x ** 2

 ---- ---- каррирование - когда из функции нескольких переменных получаем,
	  		  фактически, набор функций одной переменной

 | def summ(x,y): return x+y
 | summ_car = lambda x: lambda y: summ(x,y)
 |
 | summ_car(5)(7)	-> 12
 
 ---- ---- передача параметром функции массива (*arr)
 def f(*arr):	

 ---- ---- передача произвольного кол-ва аргументов (*args)
  | def f1(x): return x**2
  | def f2(*args): return list(map(f1, args))
  |
  | f2(1,2)	-> [1,4]


 ---- ---- передача параметром функции словаря (**kwargs)
 | def f(**kwargs):
 |	for index, val in enumerate(kwargs.item()):
 |		print(index, val)

 ---- ---- передача значений в функцию в виде списка(*args) и по ключу(**kwargs)
 | def f(*args, **kwargs):
 |   print('args', args)
 |   print('kwargs', kwargs)
 |
 | f(1,2,3,4,a='3', b=7, c=9)

 ---- массив функций
 | arrdef=[def1, def2]
 | arrdef[0](x)				-> def1(x)

 ---- словарь функций
 | dicdef = {'key1':def1, 'key2':def2 }
 | dicdef['key1'](x)			-> def1(x)

 ---- вложенные функции

 | def func(x,y):
 |	def f1(x,y): return ...
 |	def f2(x,y): return ...
 |
 |	if условие: return f1(x,y)


 ---- фильтр: filter 
 a=[0,1,2,3,4]
 print(filter(lambda x: x%2==0,a))	-> <filter object at 0x10223b630>
 print(list(filter(lambda x: x%2==0,a)))-> [0, 2, 4]
 print(map(lambda x: x*2==0,a))		-> <map object at 0x10223b630>
 print(list(map(lambda x: x*2==0,a)))	-> [True, False, False, False, False]
 print(list(map(lambda x: x*2,a)))	-> [0, 2, 4, 6, 8]

 a=[1,2]
 print(list(map(lambda x:x*x,a)))	-> [1, 4]

 ---- reduce:	from functools import reduce

 a=[0,1,2]
 a1=reduce(lambda x,y:x+y,a)	-> a1 = 3
 a1=reduce(lambda x,y:x*y,a)	-> a1 = 0

---- заполнители: pass
 ---- обработка сключений: try - except - else - finally
 ---- ---- Исключения:
 BaseException 		- базовое исключение, от которого берут начало все остальные.
   | SystemExit 	- исключение, порождаемое функцией sys.exit при выходе из программы.
   | KeyboardInterrupt 	- порождается при прерывании программы пользователем
			  (обычно сочетанием клавиш Ctrl+C).
   | GeneratorExit 	- порождается при вызове метода close объекта generator.
   | Exception 		- а вот тут уже заканчиваются полностью системные исключения
			  (которые лучше не трогать) и начинаются обыкновенные, 
			  с которыми можно работать.
   || StopIteration 	- порождается встроенной функцией next, 
-			  если в итераторе больше нет элементов.

   || ArithmeticError 	- арифметическая ошибка.
   ||| FloatingPointError - порождается при неудачном выполнении операции с плавающей запятой.
			    На практике встречается нечасто.
   ||| OverflowError 	  - возникает, когда результат арифметической операции слишком велик
			    для представления. Не появляется при обычной работе с целыми числами
			    (так как python поддерживает длинные числа),
			    но может возникать в некоторых других случаях.
   ||| ZeroDivisionError  - деление на ноль.

   || AssertionError 	- выражение в функции assert ложно.
   || AttributeError 	- объект не имеет данного атрибута (значения или метода).
   || BufferError 	- операция, связанная с буфером, не может быть выполнена.
   || EOFError 		- функция наткнулась на конец файла и не смогла прочитать то, 
			  что хотела.
   || ImportError 	- не удалось импортирование модуля или его атрибута.

   || LookupError 	- некорректный индекс или ключ.
   ||| IndexError 	- индекс не входит в диапазон элементов.
   ||| KeyError 	- несуществующий ключ (в словаре, множестве или другом объекте).

   || MemoryError 	- недостаточно памяти.

   || NameError 	- не найдено переменной с таким именем.
   ||| UnboundLocalError - сделана ссылка на локальную переменную в функции,
			   но переменная не определена ранее.

   || OSError 			- ошибка, связанная с системой.
   ||| BlockingIOError
   ||| ChildProcessError 	- неудача при операции с дочерним процессом.
   ||| ConnectionError 		- базовый класс для исключений, связанных с подключениями.
   |||| BrokenPipeError
   |||| ConnectionAbortedError
   |||| ConnectionRefusedError
   |||| ConnectionResetError
   ||| FileExistsError 		- попытка создания файла или директории, которая уже существует.
   ||| FileNotFoundError 	- файл или директория не существует.
   ||| InterruptedError 	- системный вызов прерван входящим сигналом.
   ||| IsADirectoryError 	- ожидался файл, но это директория.
   ||| NotADirectoryError 	- ожидалась директория, но это файл.
   ||| PermissionError 		- не хватает прав доступа.
   ||| ProcessLookupError 	- указанного процесса не существует.
   ||| TimeoutError 		- закончилось время ожидания.

   || ReferenceError 		- попытка доступа к атрибуту со слабой ссылкой.
   || RuntimeError 		- возникает, когда исключение не попадает 
				  ни под одну из других категорий.
   || NotImplementedError 	- возникает, когда абстрактные методы класса требуют
				  переопределения в дочерних классах.
   
   || SyntaxError 		- синтаксическая ошибка.
   ||| IndentationError 	- неправильные отступы.
   |||| TabError 		- смешивание в отступах табуляции и пробелов.

   || SystemError 	- внутренняя ошибка.
   || TypeError 	- операция применена к объекту несоответствующего типа.
   || ValueError 	- функция получает аргумент правильного типа, но некорректного значения.

   || UnicodeError 		- ошибка, связанная с кодированием / раскодированием
				  unicode в строках.
   ||| UnicodeEncodeError 	- исключение, связанное с кодированием unicode.
   ||| UnicodeDecodeError 	- исключение, связанное с декодированием unicode.
   ||| UnicodeTranslateError 	- исключение, связанное с переводом unicode.

   || Warning 			- предупреждение.


  Exception		- наиболее общий
  except:		- совсем общий случай

  Чтобы поймать ошибку, нужно идти от частного к общему
 ---- ---- 

  except (ValueError, TypeError):	- несколько исключений сразу

 ---- ---- создание своего исключения
  class NameExcept(Exception):		- создание своего исключения
	...
 try:
    raise NameExcept() 	- raise использовался для того, чтобы именно вызвать то
			  исключение, которое мы описали.
			  raise - возбудить исключение.
 except NameExcept:
    ... 
 ---- ---- 

 ---- отладка:	assert

 =======================================

 ==== модули ====
 import module
    module.def()		- вызов функции из модуля

 import ... as ...		- исп-ть псевдоним
						 import cat as tom - позволит использовать все функции 
						 модуля cat под именем tom

 from ... import ...	// from module import def	// from module import *
	def()				- вызов функции из модуля

 ---- Системные запросы
 модули: 
 ---- sys:
  .version
  .executable		- Расположение интерпретатора
  .path				- Пути поиска модулей

 ---- keyword:		список всех ключевых слов языка Python
  .iskeyword() 		- является ли слово зарезервированным.
  .kwlist			- Ключевые слова

 ================
 ==== время ====
 from datetime import *		(year, month, day, hour, minute, second, microsecond)

 datetime.
 .today()				- текущая дата и время (type: кортеж)
						  date = datetime.today()
 .getattr(date, attr)	 
 .year

 .replace()				- присваивание нового значения
						  date = date.replace(year=2015)

	
 ----  date.strftime('%A')
  %A 	Полное название дня недели (%a — для сокращенного)
  %B   	Полное название месяца (%b — для сокращенного)
  %c  	Дата и время (локальные)
  %d  	Порядковый номер дня в месяце от 1 до 31
  %f  	Количество микросекунд от 0 до 999999
  %H	Десятичное представление часа от 0 до 23 (для 24-часового вида)
  %I	Десятичное представление часа от 1 до 12 (для 12-часового вида)
  %j	Порядковый номер дня в году от 0 до 366
  %m	Порядковый номер месяца от 1 до 12
  %M	Десятичное представление минут от 0 до 59
  %p	Обозначение AM (до полудня) или PM (после полудня)
  %S	Десятичное представление секунд от 0 до 59
  %w	Порядковый номер дня в неделе от 0 (воскресенье) до 6	
  %W	Порядковый номер недели в году от 0 до 53
  %X	Локальное время (%x — локальная дата)
  %Y	Полное десятичное представление года от 0001 до 9999
  		(%y — для краткого представления от 00 до 99)
  %z	Смещение часового пояса от UTC в виде +ЧЧMM или –ЧЧMM
  %Z	Название часового пояса

 ---- таймер	( 00ч 01.01.1970 )
  from time import *

  time()	- текущее время в секундах с начала эры Unix, 
			  в виде числа с плавающей точкой
			  time = time()
	
  gmtime(time)	- преобразует время, выраженное в секундах,
			  с начала эры Unix в объект struct_time с флагом
			  DST, всегда равным нулю (флаг дневного времени)

  localtime(time)	- преобразование в объект struct_time 
			  	  в соответствии с вашим локальным временем

  struct_time  	- type(number)
				  struct = localtime( time )
				  strftime()	-> type: str
				  strftime( '%A' , struct )
				- содержит: tm_year, tm_mon, tm_mday, tm_hour,
							tm_ min, tm_sec, tm_wday, tm_yday,
							tm_yday, tm_isdst
				  например: struct.tm_wday

 sleep(sec)
 ===============
 ==== регулярные выражения ====
  from re import *

  re.compile('regexp')	- шаблон

  tmp.match('str')		- соответствие шаблону  -> (obj || None) 
						obj.start()	- позиция начала совпадения
						obj.end()	- 		  конца
						obj.group()	- вся строка совпадения
 ==============================
 
 
 ==== Работа с модулями ==== 
 import os
	os.getcwd()

 import math as m
	 m.pi

 from math import pi
	 math.pi

 ==============================

==== ООП ======================

 ---- классы

 class Name :
	''' Базовый класс для всех живых существ. '''

	count = 0			# объявление переменной

	def __init__( self , chat ) : 	# метод инициализации, который вызывается
					# автоматически во время создания экземпляра
					# класса.
		self.sound = chat
		Name.count += 1		# обращение к переменной count

	def talk( self ) :
		return self.sound

 -----------------------------
 exzemplyar = ClassName()
 ----
  getattr( экземпляр, 'атрибут' ) — значение атрибута экземпляра класса;
  hasattr( экземпляр, 'атрибут' ) — True, если значение атрибута существует
  setattr( экземпляр, 'атрибут', значение ) — модифицирует существующее значение 
				    атрибута либо создает новый атрибут для экземпляра;
  delattr( экземпляр, 'атрибут' ) — удаляет атрибут из экземпляра.

 ---- вывод аттрибутов, кроме частных
 for attrib in dir( chick ) :
	if attrib[0] != '_' :		# отбрасываем частные аттрибуты
		print( attrib , ':' , getattr( chick , attrib ) )

 ---- ---- Свойства классов
 __name__ 	— имя класса
 __module__ 	— имя модуля
 __bases__ 	— кортеж базовых классов
 __doc__ 	— строка документации
 __dict__ 	- словарь, содержащим пары атрибут:значение
 __weakref__ 	- исп-ся для автоматической сборки мусора 
		  (удаления так называемых слабых ссылок)
		  в целях увеличения производительности программы.

 isinstance(exz,class)	- является ли тот или иной объект экземпляром нашего класса, а также их прототипов
 issubclass(AB,AA)	- ?
 exz.__class__		- Проверка наследования
			  от какого класса произошел экземпляр
 exz.__class__.__base__	- от какого же класса произошло наследование.
 exz.__class__.__bases__-    каких
 exz.__class__.__bases__[0].__base__ -

 ---- ---- Методы и свойства экземпляров классов
 __dict__ 	— словарь атрибутов класса
 __ class __ 	— объект-класс, экземпляром которого объект
 __init__ 	— конструктор
 __del__ 	— деструктор
 __cmp__ 	— вызывается для всех операций сравнения
 __hash__ 	— возвращает хеш-значение объекта, равное 32-битному числу
 __getattr__ 	— возвращает атрибут, недоступный обычным способом
 __setattr__ 	— присваивает значение атрибуту
 __delattr__ 	— удаляет атрибут
 __call __ 	— срабатывает при вызове экземпляра класса

 ---------------- Сборка мусора
  id()		- посмотреть ID экземпляра класса
 __del__() [деструктор]	- уничтожает экземпляра класса;
			  явно освобождает занятое пространство памяти

 del exzemplyar

 ---------------- Наследование
  from Parent1 import *
  from ... import *
  class NewClass( Parent1, Parent2, ... ) :	- приоритетный родитель первым идет
	pass			- временная заглушка

  экземпляр 		— это простая копия класса: exz = ClassName()
  производный класс 	— это новый класс, который наследует свойства родительского, 
			  от которого он произошел: class NewClass(parent):...

  class A(object): x = 6
 
 class B(A): y = 6
 ~~~ 
 class B(A): 
	def __init__(self):
		A.__init__(self)
 ~~~
  class C(A): 
	def __init__(self):
		super(C, self).__init__()	- super исп-ся если не помним как называется класс родителя

 ----------------- Полиморфизм
  Утиная типизация.
  
  Приемы «перегрузки», используемые в других языках 
  (когда в одном классе могут быть созданы методы с тем же именем, но с различным
   набором аргументов), 
  Python не поддерживает.

 ---- 
 ---- Классы (подробный разбор) 
 class Legs(object):
    count = 4                # свойство
    def getLegs(self):       # метод. 
         return self.count   # методы внутри класса, должны сам этот экземпляр класса получать.
                             # Поэтому в качестве параметров у методов должно 
			     # быть использовано слово self.

 charlie = Legs()

 charlie.count               # обратиться к св-ву count двумя способами
 charlie.getLegs()           #

 charlie.coun -= 1
 charlie.getLegs()           # -> 3

 del charlie.count           # сбросить count в исходное положение 
 charlie.getLegs()           # -> 4

 ---- ---- 
 class L(): 
	count = 4
 l1 = L()
 del L
 l1.count	# -> 4, Удаление объекта, разумеется, не приводит к удалению класса, 
			но и особенность Питона в том, что удаление самого класса не приводит
		   	к удалению объектов, которые были от него получены,
			при том со всеми свойствами, которые были изначально приведены.

 ---- ---- приватные св-ва
 class A(object):
    __x = 1			# скрыть св-во
    def __private(self): ...	# скрыть метод

 a = A()
 a.__x			# -> error
 a._A__x		# -> 1
 a._A__x=6
 a._A__private()	#

 ---- ---- классы с конструктором [__init__] (на примере с комплексными числами)
 class A(object):
    __slots__ = ('r', 'i')		# ограничиваем кол-во св-в
    def __init__ (self, x, y):
        self.r = x
        self.i = y

 comp = A(4, 5)
 comp.r			# -> 4
 
 comp2 = A()		# error, должы указать какие-то значения по умолчанию

 ---- ---- классы с деструктором [__del__]
 class A(object):
    def __init__(self):
        self.x = 10
    def __del__(self):
        print('Удалить объект')
        
 a = A()
 del a 		# -> print('Удалить объект')

 ---- --- создание списков, словарей из классов и доступ к ним
 class Object(object): 		
	def paint(self):		
		print('Рисую Object')

 class Rectangle (object):	
	def paint(self):
		print('Рисую Прямоугольник')

 class RectangleWithFill(Rectangle): 
	def paint(self):
		super(RectangleWithFill, self).paint()
		print('Рисую полный Прямоугольник')
  obj_list=[Object(), Rectangle(), RectangleWithFill()]
  for i in obj_list:
     i.paint()

  obj_dict={'obj':Object(), 'rec':Rectangle(), 'rwf':RectangleWithFill()}
  for k,v in enumerate(obj_dict):
     obj_dict[v].paint()
    
 ---- ---- 
 ----
 class B(object):
    @staticmethod
    def get_x():
        print('statickmethod')

 b=B()
 b.get_x()		# -> statickmethod
 ----
 ---- ---- Создание класса на лету

 d = type('D', (object,), {'x':5, 'y':6})
 d.x			# -> 5
 d.y			# -> 6
 type(d)		# -> <class 'type'>
 ----
 def a():
    class A(object):
        x = 5
    return A

 z = a()
 z			# -> <class '__main__.a.<locals>.A'>
 z.x			# -> 5
 ---- 
 ---- ---- [__call__]
 Он позволяет объект, который у нас получен, вызывать как функцию.

 class A(object):
    def __init__(self, x, y):		#| a = A(5,6)
        self.x = x + y			 | a.x		-> 11
    def __call__(self, x, y):		#  a(5,6)	-> 11 - без __call__, ошибка
        return x + y

 ---- Проверка принадлежности к классу

  type(a)	-> <class '__main__.A'>

 ---- ---- [__str__] 
 class A(object):
     def __str__(self):
 	return 'MyA'

 a=A()		# a -> <__main__.A object at 0x102142940>
 str(a)		#   -> 'MyA'
 ---- ----[__unicode__]

 ---- ---- Представление класса [__repr__]
 class B(object):
     def __repr__(self):
 	return 'MyB'

 b=B()		# b -> MyB


===============================
==== Основы системного программирования =========

 ==== Шифрование строк ==  import hashlib

hashlib.algorithms_available
hashlib.algorithms_guaranteed

 dir(hashlib)			-> md5, sha512, sha...
 str = hashlib.md5(b'I love')	# явное указание бинарного значение	
				// Дело в том, что питоновские алгоритмы хорошо работают с двоичной строкой,
				// 	с binary.
	// Соответственно, если мы хотим в лоб зашифровать ту или иную строчку, 
	// например, если у нас есть некая строка, и для это некой строки мы вызываем модуль hashlib, 
	// и в этом модуле вызываем метод md5, то перед тем, как мы описываем строчку, 
	// мы ставим буковку b, которая показывает, что строка у нас является бинарной.

 str = hashlib.md5(str1.encode())	# указание бинарного значения через encode()

 str.hexdigest()		- итоговое значение

 hashlib.new('text')
 str.update(b'text')
 
 ---- проверка пароля
 
  h1 = hashlib.md5(b'Python')    # Установка пароля
  p1 = h1.hexdigest()

  h2 = input('Введите пароль: ')
  h2 = hashlib.md5(h2.encode())

  if p1 == h2.hexdigest(): print('Ok')
  else: print('Пароль не правилен')
 --------------------------------------

 ---- проблемы с кириллицей
 s1 = 'Питон'
 s1.encode('utf-8')
 print(s1.encode('utf-8'))

 s2 = s1.encode('koi8-r')
 print(s2)

 s3 = s2.decode('cp1251')
 print(s3)

 b'abc'.decode('ascii')		-> 'abc’
 ---------------------------------
 ---- bytes ----
 b'bytes'				-> b'bytes'
 'Байты'.encode('utf-8')		-> b'\xd0\x91\xd0\xb0\xd0\xb9\xd1\x82\xd1\x8b'
 bytes('bytes', encoding = 'utf-8')	-> b'bytes'
 bytes('Байты', encoding = 'utf-8')	-> b'\xd0\x91\xd0\xb0\xd0\xb9\xd1\x82\xd1\x8b'
 bytes([50, 100, 76, 72, 41])		-> b'2dLH)'

 b'\xd0\x91\xd0\xb0\xd0\xb9\xd1\x82\xd1\x8b'.decode('utf-8')	-> 'Байты'

 chr(code)		- возвращает символ по номеру code
 chr(50)		-> '2'
 chr(100)		-> 'd'

 ---- ---- Bytearray - массив байт. 
	   От типа bytes отличается только тем, что является изменяемым.

 b = bytearray(b'hello world!')		-> bytearray(b'hello world!')
 b[0]					-> 104

 b[0] = b'h'				-> TypeError: an integer is required

 b[0] = 105				-> b -> bytearray(b'iello world!')

 for i in range(len(b)): b[i] += i	-> b -> bytearray(b'ifnos%}vzun,')
 ---------------

 ==== 
 ==== Работа с файлами ========

 ---- Доступ к файлам
 open()
 read(position)	- возвращает все содержимое файла
 write()	- добавляет содержимое к файлу
 close()
 readlines()	- возвращает список всех строк — каждая строка
		  является одним элементом списка.
 readline()	- чтение по строкам

 ---- ---- режима открытия файла open()
  r	- Открыть для чтения существующий файл
  w	- Открыть существующий файл для записи. 
	  Создает новый файл, если он не существует, 
	  или открывает существующий файл и стирает все его содержимое
  a	- Режим добавления текста.
	  Открывает или создает текстовый файл для записи в конец файла
  r+	- Открыть текстовый файл для чтения или записи
  w+	- Открыть текстовый файл для записи или чтения
  a+	- Открыть или создать текстовый файл для чтения или записи в конец файла
  'x'	- открытие на запись, если файла не существует, иначе исключение.

  Если после любого из перечисленных выше режимов файлов добавлен символ b,
  то операция будет относиться не к текстовому, а к двоичному файлу. 
  Например, rb или w+b.

  't' открытие в текстовом режиме (по умолчанию).
  '+' открытие на чтение и запись

 ---- ---- file.
  .name		- Имя открываемого файла
  .mode		- Режим открытия файла
  .closed	- Возвращает True, если файл был закрыт,
		  и False — если нет
  .readable()	- Логическая величина, определяющая, установлено
		  ли на файл разрешение по чтению (True или False)
  .writable()	- Логическая величина, определяющая, установлено
		  ли на файл разрешение по записи (True или False)

  .tell()	- текущая позиция
  .seek()	- новая позиция
		- способен принимать второй необязательный аргумент
		  0 — от начала, по умолчанию
		  1 — от текущего символа,
		  2 — от конца текста соответственно.

 ---- ----
 ---- ---- свойства file = open('file.txt' 'w')
 for line in file: print(line)		- вывод текста по линиям

 ---- Консервация данных:  
  import pickle		- исп-ся для преобразования данных
			С помощью этого модуля можно осуществить
			 экстренную запись информации на диск 
			и потом экстренное чтение.

 s=pickle.dumps(arr) 	- сохранить в файл объект, 
			  который нужно преобразовать
  pickle.loads(s)	- восстановления этого объекта из файла
 

  import os	- исп-ся: проверить существование сохраняемого файла 
 
  os.path.isfile()	- True - если указанный файл найден.

 .getcwd()	- показывает текущую папку
 ==== модули os, sys
 sys.platform
 sys.version

 ---- Проверка путей в системе
 os.curdir		-> '.'
 os.pardir		-> '..'
 os.environ['PATH']	-> ???
 --------------------------
 os.getcwd()			- текущая папка
 os.listdir(os.getcwd())	- содержание тек.папки
 
 os.path.
 ..join('one', 'two')		- этот join создает так называемый правильный
				  путь к файлу или путь к папке
				  [к 'one' добавляется 'two' -> one/two]
 ..isfile()			- True - если это файл
 ..exists('one/two')		- проверяет на существование
 ..basename(one/two/text.txt)	- узнает что в конце -> text.text
 ..dirname('one/two') 		- возвращает имя директории пути.
				  узнает что в начале -> one



 ---- ---- просмотр содержимого всех папок (с вложенными)
 def viewdir(dir):
    for name in os.listdir(dir):
        path = os.path.join(dir, name)

        if os.path.isfile(path): print(path)
        else:		    	 viewdir(path)

viewdir(os.getcwd())
 ---------------------

 os.chdir('/home/')		- переход по адресу
 os.mkdir('example')		- создание папки
 os.makedirs('one/two/trhee')	- создание нескольких папок
 os.rename('t1.txt','t2.txt')	- переименовывание
 os.rmdir('one') 		- удаляет только  пустую папку one
 shutil.rmtree('one')		- удаляет все дерево папок c файлами начиная с 'one'

 shutil.copy('что', 'куда/новое_название') - копирование
 shutil.move('что', 'куда/новое_название') - перемещение

 ---- ---- это просмотр имен элементов в папке, 
	   с которыми нам необходимо работать.
 filenames = os.listdir()
 for i in filenames:
    print(os.path.abspath(i))
 --------------------------------
 os.path.abspath(path) - возвращает нормализованный абсолютный путь.
 
==========================
==== Встроенные функции (все вместе. Повтор) ===============
 ---- Встроенные функции, выполняющие преобразование типов

 bool(x) 	- преобразование к типу bool, 
		  использующая стандартную процедуру проверки истинности. 
		  Если х является ложным или опущен, возвращает значение False, 
		  в противном случае она возвращает True.

 bytearray([источник [, кодировка [ошибки]]])  - преобразование к bytearray. 
		Bytearray - изменяемая последовательность целых чисел в диапазоне 0≤X<256.
		Вызванная без аргументов, возвращает пустой массив байт.

 bytes([источник [, кодировка [ошибки]]]) 	- возвращает объект типа bytes, 
	который является неизменяемой последовательностью целых чисел в диапазоне 0≤X<256.
	Аргументы конструктора интерпретируются как для bytearray().

 complex([real[, imag]])- преобразование к комплексному числу.
 dict([object]) 	- преобразование к словарю.
 float([X]) 		- преобразование к числу с плавающей точкой. 
			  Если аргумент не указан, возвращается 0.0.
 
 frozenset([последовательность]) 		- возвращает неизменяемое множество.
 int([object], [основание системы счисления]) 	- преобразование к целому числу.
 list([object]) 				- создает список.
 memoryview([object]) 				- создает объект memoryview.
 object() 					- возвращает безликий объект,
						  являющийся базовым для всех объектов.
 range([start=0], stop, [step=1]) - арифметическая прогрессия от start до stop с шагом step.
 set([object]) 			  - создает множество.
 slice([start=0], stop, [step=1]) - объект среза от start до stop с шагом step.

 str([object], [кодировка], [ошибки]) 	- строковое представление объекта. 
					  Использует метод __str__.
 tuple(obj) 				- преобразование к кортежу.

 ---- Другие встроенные функции

 abs(x) 			- Возвращает абсолютную величину (модуль числа).
 all(последовательность) 	- Возвращает True, если все элементы истинные 
				  (или, если последовательность пуста).
 any(последовательность) 	- Возвращает True, если хотя бы один элемент - истина. 
				  Для пустой последовательности возвращает False.
 ascii(object) 		- Как repr(), возвращает строку, содержащую представление объекта, 
			  но заменяет не-ASCII символы на экранированные последовательности.
 bin(x) 		- Преобразование целого числа в двоичную строку.
 callable(x) 		- Возвращает True для объекта, поддерживающего вызов (как функции).
 chr(x) 		- Возвращает односимвольную строку, код символа которой равен x.
 classmethod(x) 	- Представляет указанную функцию методом класса.

 compile(source, filename, mode, flags=0, dont_inherit=False) 
			- Компиляция в программный код,
			  который впоследствии может выполниться функцией eval или exec.
			  Строка не должна содержать символов возврата каретки
			  или нулевые байты.

 delattr(object, name) 	- Удаляет атрибут с именем 'name'.
 dir([object]) 		- Список имен объекта, а если объект не указан,
			  список имен в текущей локальной области видимости.
 divmod(a, b) 		- Возвращает частное и остаток от деления a на b.

 enumerate(iterable, start=0) 	- Возвращает итератор,
			    	  при каждом проходе предоставляющем кортеж из номера и
				  соответствующего члена последовательности.

 eval(expression, globals=None, locals=None) 	- Выполняет строку программного кода.
 exec(object[, globals[, locals]]) 		- Выполняет программный код на Python.
 filter(function, iterable) 			- Возвращает итератор из тех элементов,
						  для которых function возвращает истину.

 format(value[,format_spec]) 		- Форматирование (обычно форматирование строки).
 getattr(object, name ,[default]) 	- извлекает атрибут объекта или default.
 globals() 				- Словарь глобальных имен.
 hasattr(object, name) 			- Имеет ли объект атрибут с именем 'name'.
 hash(x) 				- Возвращает хеш указанного объекта.
 help([object])				- Вызов встроенной справочной системы.
 hex(х) 				- Преобразование целого числа в 16-теричную строку.

 id(object) 		- Возвращает "адрес" объекта. 
			  Это целое число, которое гарантированно будет уникальным 
			  и постоянным для данного объекта в течение срока его существования.
 input([prompt]) 	- Возвращает введенную пользователем строку. 
			  Prompt - подсказка пользователю.

 isinstance(object, ClassInfo) 	- Истина, если объект является экземпляром 
				  ClassInfo или его подклассом.
				  Если объект не является объектом данного типа, 
				  функция всегда возвращает ложь.
 issubclass(класс, ClassInfo) 	- Истина, если класс является подклассом ClassInfo. 
				  Класс считается подклассом себя.

 iter(x) 			- Возвращает объект итератора.
 len(x) 			- Возвращает число элементов в указанном объекте.
 locals() 			- Словарь локальных имен.
 map(function, iterator) 	- Итератор, получившийся после применения к каждому элементу
				  последовательности функции function.

 max(iter, [args ...] * [, key]) - Максимальный элемент последовательности.
 min(iter, [args ...] * [, key]) - Минимальный элемент последовательности.

 next(x) 	- Возвращает следующий элемент итератора.
 oct(х) 	- Преобразование целого числа в восьмеричную строку.

 open(file, mode='r', buffering=None, encoding=None, errors=None, newline=None, closefd=True) 
		- Открывает файл и возвращает соответствующий поток.

 ord(с) 		- Код символа.
 pow(x, y[, r]) 	- ( x ** y ) % r.
 reversed(object) 	- Итератор из развернутого объекта.
 repr(obj) 		- Представление объекта.

 print([object, ...], *, sep=" ", end='\n', file=sys.stdout) 	- Печать.

 property(fget=None, fset=None, fdel=None, doc=None)

 round(X [, N]) 			- Округление до N знаков после запятой.
 setattr(объект, имя, значение) 	- Устанавливает атрибут объекта.
 sorted(iterable[, key][, reverse]) 	- Отсортированный список.
 staticmethod(function) 		- Статический метод для функции.
 sum(iter, start=0) 			- Сумма членов последовательности.
 super([тип [, объект или тип]]) 	- Доступ к родительскому классу.
 type(object) 				- Возвращает тип объекта.
 type(name, bases, dict) 		- Возвращает новый экземпляр класса name.
 vars([object]) 			- Словарь из атрибутов объекта. 
					  По умолчанию - словарь локальных имен.
 zip(*iters) 		- Итератор, возвращающий кортежи, состоящие из соответствующих
			  элементов аргументов-последовательностей.
 
=========================================================
==== Итераторы:
 iter(arr-dict)	- создает итератор из массива или словаря или еще от чего-н

 aiter = iter('abcde')
 
 aiter.__next__()	-> a
 aiter.__next__()	-> b


 ---- import itertools
 ---- ---- аккумкляция: 
 b = itertools.accumulate([0, 1, 2])	-> <itertools.accumulate object at 0x7f3705a52bc8>
 b = list(b)				-> [0, 1, 3,]

 ---- ---- комбинации
 list(itertools.combinations('abc', 2)) -> [('a', 'b'), ('a', 'c'), ('b', 'c')]

 ---- ---- комбинации с повторениями
 list(itertools.combinations_with_replacement('abc', 2))
	->  [('a', 'a'), ('a', 'b'), ('a', 'c'), ('b', 'b'), ('b', 'c'), ('c', 'c')]

 ---- ---- комбинации: подбор из символов
 list(itertools.permutations(['a', 'b', 'c']))
	-> [('a', 'b', 'c'), ('a', 'c', 'b'), ('b', 'a', 'c'), 
	    ('b', 'c', 'a'), ('c', 'a', 'b'), ('c', 'b', 'a')]

 ---- ---- пока условие выполняется
 a = [1,2,4,5,6,1,3]
			 |   условие  |	|obj|
 list(itertools.dropwhile(lambda x: x<4, a))	-> [4, 5, 6, 1, 3]
 list(itertools.filterfalse(lambda x: x<4, a))	-> [4, 5, 6]

 	dropwhile 	- находит первое непопадание в условие и начинает выводить элементы
	filterfalse 	- элементы фильтрует по значению.

 list(itertools.takewhile(lambda x: x<4, a))	-> [1, 2]
	takewhile	- нашел первые 2 элемента, следующий не попал, 
			  соответственно, вывод массива был закончен.

 .dropwhile(func, iterable) - элементы, начиная с первого, для которого функция вернула ложь.
 .filterfalse(func, iterable) - все элементы, для которых функция возвращает ложь.
 .takewhile(func, iterable) - элементы до тех пор, пока функция возвращает истину.

 ---- ---- перебор
 list(itertools.product('ab', 'xy')) 	-> [('a', 'x'), ('a', 'y'), ('b', 'x'), ('b', 'y')]
 dict(itertools.product('ab', 'xy'))	-> {'a': 'y', 'b': 'y'}

 ---- ---- объединение списков
 a = iter([1,2,3])	b = iter([3,4,5])
 c = list(itertools.chain(a,b))			-> [1, 2, 3, 3, 4, 5]

 ---- ---- compressed
 list(itertools.compress('abcd', [1,0,0,1]))	-> ['a', 'd']

 ---- ---- Бесконечный счетчик, начиная с заданного числа
 for i in itertools.count(10):
    print(i)
    if i > 40: break	
 
 ---- ---- Бесконечный цикл
 a=[1,2,3]
 for i in itertools.cycle(a):
    print(i)

 ---- ---- .starmap
 .starmap(function, iterable) - к каждому элементу последовательности применяет функцию

 def f1(x,y): return x + y
 list(itertools.starmap(f1,[(1,2),(3,4)]))	-> [3, 7]


 ==== генераторы ====
 ---- генераторы (yield): В языке Python существует специальная 
	 	  функция-генератор, которая возвращает объект, а не
		  значение. При этом она сохраняет состояние своего
		  последнего вызова и при следующем вызове продолжает
		  работу с той же точки.

    next() - продолжить выполнение функции с той самой точки заморозки

 def gen():
    a = 1
    while a <= 4:
        yield a*a
        a+=1

 gens = gen()	-> list(gens) -> [1,4, 9, 16]

 next(gens)	-> 1
 next(gens)	-> 4

 list(gens)	-> [9, 16] ибо 1 и 4 были уже получены
		   # yeald сохраняется состояние функции,
		   # return обновляет

 ====================
 ==== Декораторы ====  
 декоратор - это особый класс или такая особая функция, в данном случае класс,
 который принимает в качестве параметра функцию и функцию же пытается нам вернуть.

 classmethod позволяет нам получать значения непосредственно из класса.

 например, нас интересует функция get_x, в которой, единственное, 
 что мы принимаем уже не слово self, а непосредственно слово "класс", 
 поэтому здесь мы и пишем сокращенную аббревиатуру cls.

 class A(object):
    x = 1
    @classmethod
    def get_x(cls):
        print(cls.x)

 a = A()
 a.x		-> 1

 a.x = 5

 a.get_x()	-> 1 : получим исходное значение, которое у нас было прописано в классе, 
        	   т. е. мы можем сравнивать значение свойства, которое у нас в настоящий
      		   момент, и то значение из класса, 
		   которое у нас было получено в самом начале.

 staticmethod существует, 
	чтобы у нас не было дополнительных возможностей по доступу к классу.

class B(object):
    @staticmethod
    def get_x():
        print('staticmethod')

 b = B()
 b.get_x()	-> staticmethod

 В случае staticmethod метод, описанный внутри класса, не принимает самого класса как себя,
 т. е. нет там слова self и нет там слова cls, т. е. в данном случае он нечувствителен к
 каким-либо изменениям, не имеет доступа к оригинальным свойствам и не может их повредить.

 ----
def mytag(tagname='p'):
    def decorated(func):
        def inner(text):
            print('<%s>'%tagname)
            func(text)
            print('</%s>'%tagname)
        return inner
    return decorated

@mytag('p')
@mytag('b')
def hello(text):
    print('Hello ', text)

hello('Python')	-> 	<p>
			<b>
			Hello  Python
			</b>
			</p>

print(hello.__name__)	-> inner - это имя неправильное

чтобы имя было правильное нужно использовать from functools import wraps
или inner.__name__ = func.__name__  перед return inner

from functools import wraps

def mytag_p(func):
    @wraps(func)
    def inner(text):
        print('<p>')
        func(text)
        print('<p>')
    return inner
    

@mytag_p
def hello(text):
    print('Hello ', text)

hello('Python')	-> 	<p>
			Hello  Python
			<p>

print(hello.__name__) 	-> hello - это имя правильное





 ====================
===============
==== XML ============
import os

# print(os.getcwd())
os.chdir('./XML_JSON_DB')

print(os.getcwd())
# print(os.listdir())

from xml.etree import ElementTree
# print(dir(ElementTree))

# file1 = open('books_ansi.xml', 'r')
file1 = open('books-utf.xml', 'r')

tree = ElementTree.parse(file1)
print(tree)

root = tree.getroot()

print(root)
print(root.tag)         # обращение к тэгу
print(root.attrib)      # обращение к аттрибутам в виде словаря

for i in root:
    print(i.tag, i.attrib)  

print(root[0][1].text)   # обращение к данным (по массиву)

# просмотр содержимого xml
for i in tree.iter():
    print(i.tag, i.attrib, i.text)

print(" +++ ")

# поиск чего-то
for i in tree.iter('person'):
    print(i.attrib)  # В данном случае у нас iter искал, пробегая по всему файлу 

# файлу, но бывают случаи, когда нам необходимо пробежаться именно по дочерним элементам с поиском того или иного значения.
for i in root.findall('book'):     # findall осуществляет поиск всех элементов, которые удовлетворяют тому или иному значению.
    year = i.find('year').text 
    pages = i.find('pages').text
    name = i.get('name')           # с помощью get мы получаем имя от текущего i-элемента
    print(year, name, pages)

#  обновление элементов в xml.
for i in root.iter('number'):
    # new_number = int(find('number').text)+1
    new_number = int(i.text)+1
    i.text = str(new_number)
    i.set('updated', '2017')

# tree.write('books-utf2.xml')

# отсортировать и убрать
for i in root.findall('book'):
    number = int(i.find('number').text)
    print(number)
    if number > 50:
        root.remove(i)      # удаление

for i in root.findall('book'):
    number = int(i.find('number').text)
    print(number)

# создавать новый элемент
book = ElementTree.Element('Barmaley')         # создать елемент
number = ElementTree.SubElement(book, '200')   # создать поделемент
year = ElementTree.SubElement(book, '2017')

ElementTree.dump(book)    # увидеть, что же мы такое создали

number.set('number', '200')   # добавляет аттрибут
ElementTree.dump(book)

book = ElementTree.Element('Aybolit')
number = ElementTree.SubElement(book, 'number').set('number', '500') 
ElementTree.dump(book)

# обновление елементов дерева  [append]
root.append(book)
ElementTree.dump(book)


=====================
==== JSON ===========

import json

# преобразование в json объект
json_list = json.dumps(arr)

# чтобы сузить, надо указать разделители | separators
json_list2 = json.dumps(alist, separators=(',',':'))

# чтобы разнести | indent
json_list3 = json.dumps(alist, separators=(',',':'), indent=4)

# сортировка строк по ключам | sort_keys
json_list4 = json.dumps(alist, separators=(',',':'), indent=4, sort_keys=True)

# json -> python  | loads
alist2 = json.loads(json_list2)
# !!! кортедж переводится в массив

=====================
==== Data Base == db ====
import sqlite3

print(sqlite3.apilevel)   # версия api

# обращение к db  | connect
con = sqlite3.connect('testdb.db')

# создать таблицу
cur=con.cursor()
# создание sql скрипта
sql="""
CREATE TABLE author(
    id_author INTEGER PRIMARY KEY,
    name_author TEXT,
    descr_author TEXT
);
"""
# исполнение sql скрипта
cur.executescript(sql)
cur.close()
con.close()
=================================

==== mysql ====	
pip p install PyMySQL

===============
==== Получение информации о web страницах ====
import urllib.request
import urllib.parse

url_file = urllib.request.urlopen('http://djbook.ru') 
# .urlopen    - открывать и считывать какую-либо информацию.

html_file = url_file.read()
html_file = html_file.decode('utf-8')
or
html_file = html_file.decode('cp1251')

url_file.info()
x = url_file.getcode()

# парсинг вариант 1
from urllib.parse import urlparse
from urllib.parse import urlunparse

url_res = urlparse('https://djbook.ru/rel1.9/contents.html')

url_res.netloc     # djbook.ru

url_res_tuple = tuple(url_res)       # ('https', 'djbook.ru', '/rel1.9/contents.html', '', '', '')
url_res2 = urlunparse(url_res_tuple) # https://djbook.ru/rel1.9/contents.html

# парсинг вариант 2
from urllib.parse import urlsplit
from urllib.parse import urlunsplit

url_res = urlsplit('https://djbook.ru/rel1.9/intro/tutorial07.html')
url_res_tuple = tuple(url_res)
url_res2 = urlunsplit(url_res)

url_res = urlsplit('https://djbook.ru/rel1.9/intro/tutorial07.html')
url_res_list = list(url_res)

url_res_list[2] = '/rel1.9/intro/tutorial06.html'

url_new_tuple=tuple(url_res_list)
url_new = urlunsplit(url_new_tuple)

from urllib.parse import urljoin

urljoin('https://djbook.ru/rel1.9/intro/tutorial07.html', 'intro2/tutorial06.html')
urljoin('https://djbook.ru/rel1.9/intro/tutorial07.html', '../../tutorial06.html')

==== веб-сервер ====

====================
==============================================
===== из Лутца ======

---- pprint форматированный вывод		[54]
import pprint
pprint.pprint(db)
----


===================================
== парсинг ==
from urllib.request import urlopen
# html = urlopen('http://pythonscraping.com/pages/page1.html')
print(html.read())

-- beautifulSoup --
url2 = 'http://bit.ly/1KGe2Qk'
html = urlopen(url2)
bsObj = BeautifulSoup(html)

.read()
.get()
.get_text()
.findAll() || .find_all()
.find()						// .find("tag", class_="name")
							// .find("tag", text="name")
							// .find("tag", {"data-set"="name"})
.children		
.descendants	- потомки

.next_sibling
.find_next_sibling()

.netx_siblings


.previous_sibling
.find_previous_sibling()

.previous_siblings

.parent
.find_parent(class_="class_name")

.parents
.find_parents(class_="class_name")

.attrs['src']

nameList = bsObj.findAll("span", {"class":"green"}).children
for name in nameList:
    print(name.get_text())

-- таблицы csv --
from io import StringIO
import csv

html = urlopen("http://www.pythonscraping.com/files/MontyPythonAlbums.csv")
	.read()
	.decode('ascii', 'ignore')

dataFile = StringIO(html)
csvReader = csv.reader(dataFile)
// csvReader = csv.DictReader(dataFile)		-> в виде словаря
for row in csvReader:
    print(row)



-----------------
-- задание headers, User-Agent --
import requests 
from bs4 import BeautifulSoup

session = requests.Session()
headers = {
    "User-Agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_5) AppleWebKit 537.36 (KHTML, like Gecko) Chrome",
    "Accept":"text/html, app;ication/xhtml+xml, application/xml; q=0.9,image/webp,*/*;q=0.8"}

url = "https://www.whatismybrowser.com/developers/what-http-headers-is-my-browser-sending"
req = session.get(url, headers=headers)
bsObj = BeautifulSoup(req.text)
print(bsObj.find("table", {"class":"table-striped"}).get_text)


 -- scrapy
 pip install scrapy
scrapy startproject pro
 

=============

