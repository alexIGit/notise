
window.onload = function () { };	// Все объекты в DOM и все изображения, 					   скрипты, ссылки и подфреймы уже загружены.
document.onload = function () { };	!+// Вызывается по мере готовности DOM, что может произойти
					   до готовности изображений и другого внешнего содержимого.
$(document).ready(function () { });	// Способ с jQuery 

---- асинхронные скрипты ------------
 async		- загружает скрипт полностью асинхронно
 defer		- загружает скрипт асинхронно, но сохраняет порядок выполнения скриптов
--------------------------------------
===============================================================================================================
 
 "use strict"	- строгий режим
 Для того, чтобы интерпретатор работал в режиме максимального соответствия современному стандарту, нужно начинать скрипт директивой 'use strict';

---- типы данных --------------------
 number		||	Infinity = 1/0	|| NaN = text*2 - не число
 string
 boolean
 undefined
 null		- спец. значение (сам себе тип)
 object
 --- typeof x 	- возвращает тип данных  
 
 typeof 1 ;         	// 'number'
 typeof true ;      	// 'boolean'
 typeof "Текст" ;   	// 'string'
 typeof undefined ; 	// 'undefined'
 typeof null ;      	// 'object' (ошибка в языке)
 typeof alert ;     	// 'function'

 typeof {} ; 		// 'object'
 typeof [] ; 		// 'object'
 typeof new Date ; 	// 'object'

 ---- ---- [[Class]]
 Во всех встроенных объектах есть специальное свойство [[Class]],
 в котором хранится информация о его типе или конструкторе.

 Его внутренняя реализация выводит [[Class]] в небольшом обрамлении, 
 как "[object значение]".

 	var toString = {}.toString;

	var arr = [1, 2];
	alert( toString.call(arr) ); 		// [object Array]

	var date = new Date;
	alert( toString.call(date) ); 		// [object Date]

	var user = { name: "Вася" };
	alert( toString.call(user) ); 		// [object Object]

	alert( {}.toString.call(123) ); 	// [object Number]
	alert( {}.toString.call("строка") ); 	// [object String]

 ---- ---- .isArray()
 Array.isArray(arr)				// true, если arr – массив

 ---- ---- instanceof()
 instanceof 	- позволяет проверить, создан ли объект данной функцией, 
		  причём работает для любых функций – как встроенных, так и наших.

	Вызов obj instanceof Constructor возвращает true, 
	если объект принадлежит классу Constructor 
	или классу, наследующему от него.

	
	function User() {}
	var user = new User();
	alert( user instanceof User ); // true


Алгоритм проверки obj instanceof Constructor:

 1. Получить obj.__proto__
 2. Сравнить obj.__proto__ с Constructor.prototype
 3. Если не совпадает, тогда заменить obj на obj.__proto__ 
    и повторить проверку на шаге 2 до тех пор, 
    пока либо не найдется совпадение (результат true), 
    либо цепочка прототипов не закончится (результат false).

-------------------------------------

---- взятие остатка % ---------------				
 8 % 3 // 2
 6 % 3 // 0
-------------------------------------

---- икремент/декремент -------------
 var a = ++i; // a=i+1
 var a = i++; // a=i; а потом i=i+1;
-------------------------------------

---- побитовые операции ------------ приоритет меньше, чем у ==
 AND или &
 OR  или |
 XOP или ^	- исключающее или (0 - сигналы равны, 1 - разные) a^b^b==a
 NOT или ~
 LEFT SHIFT  или << (почти равен *2)
 RIGHT SHIFT или >> (почти равен /2)
 ZERO-Fill RIGHT SHIFT или >>>	- правый сдиг с заполнением нулями
------------------------------------
---- логические операторы ----------
 || 	
 &&	
 !	(!! преобразует значение к логическому типу) 
------------------------------------
---- преобразования ----------------
 		численное	логическое
 undefined	NaN		false
 null		0		false
 true/false	1/0		-----
 ""		0
 число, кроме{	-------		1
 0		-------		false
 NaN	}	-------		false
 Object		-------		true

------------------------------------

parseInt("11000", 2)	- переводит "11000" в число с  
n.toString(2)		- переводит n в число в 2-й системе

---- Приоритетность операторов -----
 () [] . 	- Скобки, вызов и составляющая объекта
 ++ –– 		- Инкремент и декремент
 + – ~ ! 	- Унарные, поразрядные и логические
 * / % 		- Арифметические
 + – 		- Арифметические и строковые
 << >> >>> 	- Поразрядные
 < > <= >= 	- Сравнения
 == != === !== 	- Сравнения
 & ^ | 		- Поразрядные
 && 		- Логический
 || 		- Логический
 ? : 		- Трехкомпонентный
 = += –= *= /= 	|
 %= <<= >>=	| - Присваивания
 >>>= &= ^= |=	|		
 
 ,		- Разделитель
-----------------------------------------
---- Сравнение ---------------
 ===	- проверяет точное равенство, включая одинаковый тип
 Остальные сравнения == < <= > >= осуществляют числовое приведение типа

 null == undefined и не равны ничему ещё. В частности, не равны нулю.
 В других сравнениях (кроме === ) значение null преобразуется к нулю, а undefined — становится NaN («ошибка»).
 
 alert( null > 0 );  // false, т.к. null преобразовано к 0
 alert( null >= 0 ); // true, т.к. null преобразовано к 0
 alert( null == 0 ); // false, в стандарте явно указано, что null равен лишь undefined

 Сравнение строк — лексикографическое, символы сравниваются по своим unicode-кодам.
 справа больше
 А-Яа-я
 alert( 'а' > 'Я' ); // true
-----------------------------
---- инструкция with --------------------
 var string = "Шустрая быстрая лисица"; 

 with( string ) {
	document.write("В строке " + length + " символов<br>");
	document.write(toUpperCase() );
 }
 ---- ---- Замена with
 Вместо with рекомендуется использовать временную переменную, например:
  /* вместо
	with(elem.style) {
	  top = '10px';
	  left = '20px';
	}
 */

	var s = elem.style;
	s.top = '10px';
	s.left = '0';
===============================================================================================================

==== Циклы ======================================================================
 while (условие) { ... }

 do { ... } while (условие);

 for (var i = 0; i < 10; i++) { ... }

 Переменную можно объявлять прямо в цикле, но видна она будет и за его пределами.
 Поддерживаются директивы break/continue для выхода из цикла/перехода на следующую итерацию.
 Для выхода одновременно из нескольких уровней цикла можно задать метку.
 Синтаксис: «имя_метки: », ставится она только перед циклами и блоками, например:

 outer: 
	for(;;) { ... for(;;) {
				...
				break outer; } }
 Переход на метку возможен только изнутри цикла, и только на внешний блок по отношению к данному циклу. В произвольное место программы перейти нельзя.

-----------------------

---- Конструкция switch ----------
 При сравнениях в конструкции switch используется оператор === . Например:

 var age = prompt('Ваш возраст', 18);

 switch (age) {
  case 18:
    alert( 'Никогда не сработает' ); // результат prompt ‐ строка, а не число
  case "18": // вот так ‐ сработает!
    alert( 'Вам 18 лет!' );
    break;
  default:
    alert( 'Любое значение, не совпавшее с case' );
}
-------------------------------------

---- Использование события onerror -------------

 onerror = errorHandler;

 function errorHandler(message, url, line) {
	out = "К сожалению, обнаружена ошибка.\n\n";
	out += "Ошибка: " + message + "\n";
	out += "URL: " + url + "\n";
	out += "Строка: " + line + "\n\n";
	out += "Щелкните на кнопке OK для продолжения работы.\n\n";
	alert(out);
	return true;
}
---------------------------------------------------------------

---- Взаимодействие с посетителем
 prompt(вопрос[, по_умолчанию])	-  { null , если посетитель нажал «Отмена».}
 confirm(вопрос)		-  true/false 
 alert(сообщение) 
-------------------------

==== Массивы ======================================================================
 var arr = [];
 var arr = new Array();
	var arr = new Array(2, 3);	// создан массив [2, 3]
	var arr = new Array(2); 	// у нас массив без элементов, длины 2
 --- Ассоциативные массивы ---
 balls = {
	"гольф": 	"Мячи для гольфа, 6",
	"теннис": 	"Мячи для тенниса, 3",
 }
 ---- методы ---- 
 pop		- Удаляет последний элемент из массива и возвращает его
 push		- Добавляет элемент в конец массива
		  Вызов fruits.push(...) равнозначен fruits[fruits.length] = ...

 shift		- Удаляет из массива первый элемент и возвращает его
 unshift	- Добавляет элемент в начало массива
		  
 		  push/pop выполняются быстро
		  shift/unshift – медленно.

 split(s)	- позволяет превратить строку в массив, разбив ее по разделителю s.
			var names = 'Маша, Петя, Марина, Василий';
			var arr = names.split(', ');
			for (var i = 0; i < arr.length; i++) { alert( 'Вам сообщение ' + arr[i] ); }
		  
		  есть необязательный второй аргумент – ограничение на количество элементов в массиве.
			"a,b,c,d".split(',', 2) ); 	// a,b

		  Вызов split с пустой строкой разобьёт по буквам

 arr.join(str) 	- делает в точности противоположное split. 
		  Он берет массив и склеивает его в строку, используя str как разделитель.
			var arr = ['Маша', 'Петя', 'Марина', 'Василий'];
			var str = arr.join(';');
			alert( str ); 			// Маша;Петя;Марина;Василий

 delete		- удаление ключа из массива
			var arr = ["Я", "иду", "домой"];
			delete arr[1]; 				// значение с индексом 1 удалено
							    	// теперь arr = ["Я", undefined, "домой"];
			alert( arr[1] ); 			// undefined

 splice 	– Умеет все: удалять элементы, вставлять элементы, заменять элементы – по очереди и одновременно.

		Его синтаксис:	arr.splice(index[, deleteCount, elem1, ..., elemN])
			Удалить deleteCount элементов, начиная с номера index, 
			а затем вставить elem1, ..., elemN на их место.
			Возвращает массив из удалённых элементов.

 		I.	var arr = ["Я", "сейчас", "изучаю", "JavaScript"];
							// удалить 3 первых элемента и добавить другие вместо них
			arr.splice(0, 3, "Мы", "изучаем")
			alert( arr ) 			// теперь ["Мы", "изучаем", "JavaScript"]

		II.	var arr = ["Я", "изучаю", "JavaScript"];
								// с позиции 2
								// удалить 0
								// вставить "сложный", "язык"
			arr.splice(2, 0, "сложный", "язык");
			alert( arr ); 				// "Я", "изучаю", "сложный", "язык", "JavaScript"
			
		Допускается использование отрицательного номера позиции, 
			которая в этом случае отсчитывается с конца
			позиция с индексом -1 - перед последним элементом

 slice(begin, end) 	- копирует участок массива от begin до end, не включая end.
			  Исходный массив при этом не меняется.



 sort() 		- сортирует массив на месте. сортирует как строки
				var arr = [ 1, 2, 15 ];
				arr.sort();
				alert( arr );  			// 1, 15, 2

			I.	function compareNumeric(a, b) {	if (a > b) return 1;
								if (a < b) return -1; }
				var arr = [ 1, 2, 15 ];
				arr.sort(compareNumeric);
				alert(arr);  			// 1, 2, 150		
			Обратите внимание, мы передаём в sort() именно саму функцию compareNumeric, 
				без вызова через скобки.
			Был бы ошибкой следующий код: arr.sort( compareNumeric() );  // не сработает
 

 .reverse()	- меняет порядок элементов в массиве на обратный.

 .concat() 	- объединяет два массива или ряд значений в массив
		  arr.concat(value1, value2, … valueN) 
		  создаёт новый массив, в который копируются элементы из arr, а также value1, value2, ... valueN.
			var arr = [1, 2];
			var newArr = arr.concat(3, 4);
			alert( newArr ); 		// 1,2,3,4

 .indexOf()	- возвращает номер элемента searchElement в массиве arr или -1, если его нет.
		  arr.indexOf(searchElement[, fromIndex])
		  Поиск начинается с номера fromIndex, если он указан. Если нет – с начала массива.
		  Для поиска используется строгое сравнение ===.
 .lastIndexOf()	- ищет справа-налево
		  Методы indexOf/lastIndexOf осуществляют поиск перебором

 Object.keys(obj)	- var user = { 	name: "Петя",
					age: 30		}
			  var keys = Object.keys(user);
			  alert( keys ); 		// name, age

 ---- ---- перебирающие методы

 .forEach( function(){} )	- воспользоваться этим методом можно, передав ему имя функции, которая будет вызвана
		  		  для каждого элемента массива
		  		 | pets = ["Кошка", "Собака", "Кролик", "Хомяк"];
		  		 | pets.forEach(output);
				 |
		  		 | function output(element, index, array) {
				 |	document.write("Элемент с индексом " + index + " содержит значение "
				 |	 + element + "<br>") ;
		  		 |  }
 				forEach ничего не возвращает, его используют только для перебора,
				как более «элегантный» вариант, чем обычный цикл for.
	
 .filter( function(){} )	- создаёт новый массив, в который войдут только те элементы arr,
				  для которых вызов callback(item, i, arr) возвратит true
				
				| var arr = [1, -1, 2, -2, 3];
				|
				| var positiveArr = arr.filter( function(number) { return number > 0; }); // 1,2,3

.map( function(){} )	- используется для трансформации массива.
			  Он создаёт новый массив, который будет состоять из результатов вызова
				callback(item, i, arr) для каждого элемента arr.
			| var names = ['HTML', 'CSS', 'JavaScript'];
			| 
			| var nameLengths = names.map(function(name) { return name.length; }); // 4,3,10

 .every()		- возвращает true, если вызов callback вернёт true для каждого элемента arr.
 .some()		- возвращает true, если вызов callback вернёт true для какого-нибудь элемента arr.
			  | var arr = [1, -1, 2, -2, 3];
			  | function isPositive(number) { return number > 0; }
			  |
			  | arr.every(isPositive) ; 	// false, не все положительные
			  | arr.some(isPositive)  ; 	// true, есть хоть одно положительное

 .reduce()		-| используется для последовательной обработки каждого элемента массива 
 .reduceRight()		 | с сохранением промежуточного результата.	
			   Он применяет функцию callback по очереди к каждому элементу массива слева направо,
			   сохраняя при этом промежуточный результат.
			| var arr = [1, 2, 3, 4, 5]
			|
			| // для каждого элемента массива запустить функцию,
			| // промежуточный результат передавать первым аргументом далее
			| var result = arr.reduce(function(sum, current) {
			|   return sum + current;
			| }, 0);
			|
			| result; 	// 15

 ---- Перебор элементов ----
 I. 	for (var i = 0; i < arr.length; i++) {		}
 II.	Не используйте for..in для массивов

 ----------------------
 Длина length – не количество элементов массива, а - последний индекс + 1

 ---- arguments - Псевдомассив аргументов

 function showWarning(options) {
  var width = options.width || 200; // по умолчанию
  var height = options.height || 100;
  var contents = options.contents || "Предупреждение";
  // ...
 }
 showWarning({
  contents: "Вы вызвали функцию" // и всё понятно!
 });

===============================================================================================================

==== Числа =====================================================================
 0xFF		- [255] 16-я форма записи
 010		- [8]	8-я
 1e3		- [1000] научная форма записи

 NaN == NaN	// не сработает
 NaN === Nan	// не сработает

 isNaN		- праверка на NaN
 isNaN('12')	// false
 NaN+1		// NaN
 
 isFinite(n)	- true, если это не NaN/Infinity/‐Infinity

 +"12test"	// NaN
 +"   -12  "	// -12 пробел по краям
 +"1 2"		// NaN пробел по серидине
 
 parseInt("12px")	// 12 Преобразует до целого
 parseFloat("12.3.4")	// 12,3 преобразует до дробного

 
 проверка на число 
 function isNumeric(n){ return !isNaN(parseFloat(n)) && is Finite(n) }

 n.toString(система счисления)	- 255.toString(16)	// ff

 --- Округление ---
 num.toFixed(n)		- округление до n после запятой
 Math.floor		- окр. вниз
 Math.ceil		-      вверх
 Math.round		-      до ближайщего целого (5 окр-ся вверх)

 Округление битовыми операторами	- отсекает дробную часть
 ~~12.3		// 12
 12.3^0		// 12
 1.2+1.3^0	// 2

 ----------------

 Math.acos(x)		- Возвращает арккосинус x (в радианах)
 Math.asin(x)		- Возвращает арксинус x (в радианах)
 Math.atan(x)		- Возвращает арктангенс x (в радианах)
 Math.atan2(y, x)	- Возвращает угол до точки (y, x) . Описание функции: Atan2
 Math.sin(x)		- Вычисляет синус x (в радианах)
 Math.cos(x)		- Вычисляет косинус x (в радианах)
 Math.tan(x)		- Возвращает тангенс x (в радианах)

 Math.sqrt(x)		- Возвращает квадратный корень из x .
 Math.log(x)		- Возвращает натуральный (по основанию e ) логарифм x .
 Math.pow(x, exp) 	- Возводит число x в степень exp 
 Math.abs(x) 		- Возвращает абсолютное значение числа
 Math.exp(x)		- Возвращает e^x , где e — основание натуральных логарифмов.
 Math.max(a, b, c...)	- Возвращает наибольший из списка аргументов
 Math.min(a, b, c...)	- Возвращает наименьший из списка аргументов
 Math.random()		- Возвращает псевдо-случайное число в интервале [0,1)

 number.toLocaleString() // 123 456 789 Для красивого вывода чисел в стандарте
  
===============================================================================================================

==== Строки =====================================================================================
 \b 	Backspace
 \f 	Form feed
 \n 	New line
 \r 	Carriage return
 \t	Tab
 \uNNNN	\u00A9 — юникодное представление символа копирайт

 str.length		- .Свойство 
 str.toUpperCase()	- .Метод()
    .toLowerCase() 	- 
    .substr(1)		- извлечения строки с позиции 1 до конца

    .charAt(0)		- получить символ из позиции
			  jQuery.chartAt(0)	// j
 str[0]			- str = jQuery; str[0] 	// j

    .tirm()		- удаляет пробелы (а также переводы строк, 
			  табуляцию и прочие подобные символы) с обоих концов строки.
 "  ладно  \n ".trim()); // → ладно

 Разница между str[] и charAt заключается в том, что если символа нет — charAt выдает пустую строку, а скобки — undefine

 --- Поиск подстроки --- indexOf()
 indexOf(подстрока[, начальная_позиция]) - Он возвращает позицию, на которой находится подстрока или ‐1 , если ничего не найдено.
 var str = "Widget with id";
 str.indexOf("Widget") 	// 0, т.к. "Widget" найден прямо в начале str
 str.indexOf("id") 	// 1, т.к. "id" найден, начиная с позиции 1
 str.indexOf("widget") 	// ‐1, не найдено, так как поиск учитывает регистр
 str.indexOf("id", 2) 	// 12, поиск начат с позиции 2

 lastIndexOf()		- ищет не с начала, а с конца строки.
 
 --- Взятие подстроки --- substr, substring, slice
 substring(start, end)	- возвращает подстроку с позиции start до, но не включая end .
	'stringify'.substring(0,1)	// "s" символы с позиции 0 по 1 не включая 1.
  	'stringify'.substring(2)	// ringify, символы с позиции 2 до конца
 	Отрицательные аргументы интерпретируются как равные нулю. 
	Слишком большие значения усекаются до длины строки
	если start > end , то аргументы меняются местами

 substr(start [, length])
	'stringify'.substr(2,4); 		// ring, со 2й позиции 4 символа
 
 slice(start [, end])	- Возвращает часть строки от позиции start до, но не включая, позиции end.
	Отрицательные значения отсчитываются от конца строки
	"testme".slice(‐2) 		// "me", от 2 позиции с конца
 ----------------------------
 str.fromCharCode(code)		- Возвращает символ по коду code
				  String.fromCharCode(1072) ); // 'а'
 str.charCodeAt(pos)		- Возвращает код символа на позиции pos
				  "абрикос".charCodeAt(0) ); // 1072, код 'а'
==========================================================================================================


==== Объекты как ассоциативные массивы ====== kantor[209] =============

 --- Создание объектов
 o = new Object();
 o = {}; // пустые фигурные скобки

 --- Доступ к свойствам:
 1. person.name = 'Вася';
 2. person['name'] = 'Вася';
 3. var person = { age: 25 };
    var key = 'age';
    alert( person[key] ); // выведет person['age']

 --- Удаление свойства (delete):
 delete person.age;

 --- Проверка существования свойства с определенным ключом:
 1. if ("name" in person) { alert( "Свойство name существует!" ); }

 2. var person = { name: "Василий" };
	alert( person.lalala === undefined ); // true, свойства нет
	alert( person.name === undefined ); // false, свойство есть.

 оператор in гарантирует правильный результат

 --- Объекты: перебор свойств 
 -- for in --
 for (var key in menu) {
  // этот код будет вызван для каждого свойства объекта
  // ..и выведет имя свойства и его значение
  alert( "Ключ: " + key + " значение:" + menu[key] );
 }
 мы использовали квадратные скобки menu[key] . Если имя свойства хранится в переменной, то обратиться к нему можно только так, не через точку.
 
 -- for of -- 
 let arr = [ 3, 5, 7 ];
 arr.foo = "hello";
 
 for (let i in arr) { console.log(i); // выведет "0", "1", "2", "foo" }
 for (let i of arr) { console.log(i); // выведет "3", "5", "7" }


 --- Количество свойств в объекте

 1. var counter = 0;
    for (var key in menu) { counter++; }
 2. Object.keys(menu).length
 
 ---
 	● Порядок перебора соответствует порядку объявления для нечисловых ключей, а числовые — сортируются (в современных браузерах).

	● Если нужно, чтобы порядок перебора числовых ключей соответствовал их объявлению в объекте, то используют трюк:
 числовые ключи заменяют на похожие, но содержащие не только цифры.
 Например, добавляют в начало + , как описано в примере выше, а потом, в процессе обработки, преобразуют такие ключи в числа.


 --- Копирование по ссылке
 При копировании переменной с объектом — копируется эта ссылка, а объект по-прежнему остается в единственном экземпляре.

Так как объект всего один, то изменения через любую переменную видны в других переменных:

 	var user = { name: 'Вася' }; 	// Получили две переменные, 
	var admin = user;		// в которых находятся ссылки на один и тот же объект
 	
	admin.name = 'Петя'; // поменяли данные через admin
	alert( user.name ); // 'Петя', изменения видны в user

 --- Клонирование объектов
	---- массивы ----:[wes bos][14]
	const players = ['Wes', 'Sarah', 'Ryan', 'Poppy'];
    // #1
    const team2 = players.slice();
    // #2
    const team3 = [].concat(players);
    // #3
    const team4 = [...players]
    // #4
    const team5 = Array.from(players);
	-----------------

    ---- поиск ----
    arr.find(post => post.code === code)  		// -> post{code:..., ...}
    arr.findIndex(post => post.code === code)   // -> index  // Позиция в массиве
    ---------------
	---- объекты ----:[wes bos][14]
	const person = { что-то };
 
   const cap2 = Object.assign({}, person, {number: 99, age: 12});
   const cap3 = {...person};
   // если в person имеется obj, то в cap2, cap3 будет этот же obj
   // исправить можно ->
   const dev2 = JSON.parse(JSON.stringify(person));	// глубокое клонирование
	-----------------
	var user = { name: "Вася", age: 30 };
	var clone = {}; 			// новый пустой объект
						// скопируем в него все свойства user
	for (var key in user) { clone[key] = user[key]; }
						// теперь clone ‐ полностью независимая копия
	clone.name = "Петя"; 			// поменяли данные в clone
	alert( user.name ); 			// по‐прежнем "Вася"

 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 Объект присваивается и копируется «по ссылке». 
	То есть, в переменной хранится не сам объект а, условно говоря, адрес в памяти, где он находится.
 Если переменная-объект скопирована или передана в функцию,
	то копируется именно эта ссылка, а объект остаётся один в памяти.
 Это – одно из ключевых отличий объекта от примитива (числа, строки…), 
	который при присвоении как раз копируется «по значению», то есть полностью.
 ----------------------------------------------------------------------------------------
 
============================================================================================
==== Регулярные выражения. RegExp ===============================================================================

 var regexp = new RegExp("шаблон", "флаги");
 var regexp = /шаблон/gmi; 			// с флагами gmi (изучим их дальше)

  ---- Флаги --------------------------------------------------
 i	- регэксп ищет независимо от регистра.
 g	- регэксп ищет все совпадения, иначе – только первое.
 m	- Многострочный режим.
 ---------------------------------------------------------------
 ---- Методы ---------------------------------------------------
 
 str.search(regexp)	- возвращает позицию 1-го совпадения или -1, если ничего не найдено.
			  он всегда ищет только первое совпадение

 str.match(reg)		- находит только одно, первое совпадение.
			  это массив, состоящий из этого совпадения, с дополнительными свойствами 
				index – позиция, на которой оно обнаружено 	
				input – строка, в которой был поиск.
			  Если часть шаблона обозначена скобками, то она станет отдельным элементом массива.
			  если совпадений не было, match возвращает null ()

 str.match(reg/g)	- При наличии флага g, вызов match возвращает обычный массив из всех совпадений.
			  доп. свойств (index, input) - нет
			  скобок () - нет

 str.split(reg|substr, limit)	- Разбивает строку в массив по разделителю.
				  substr: 	'12-34-56'.split('-')	 	// [12, 34, 56]
				  regexp:	'12-34-56'.split(/-/)		// [12, 34, 56]

 str.replace(reg, str|func)	- поиск и замена подстроки в строке
	
				  // заменить дефис на двоеточие
				'12-34-56'.replace("-", ":") 	// 12:34-56
				При вызове со строкой замены replace всегда заменяет только первое совпадение.

				Чтобы заменить все совпадения, нужно использовать для поиска не строку "-", 
				а регулярное выражение /-/g, причём обязательно с флагом g:

                                // заменить дефис на двоеточие
				'12-34-56'.replace( /-/g, ":" )   // 12:34:56
	
 Спецсимволы:	
	$$	Вставляет "$".
	$&	Вставляет всё найденное совпадение.
	$`	Вставляет часть строки до совпадения.
	$'	Вставляет часть строки после совпадения.
	$*n*	где n -- цифра или двузначное число, обозначает n-ю по счёту скобку, если считать слева-направо.

	var str = "Василий Пупкин";
	str.replace(/(Василий) (Пупкин)/, '$2, $1') 	// Пупкин, Василий
 	str.replace(/Василий Пупкин/, 'Великий $&!') 	// Великий Василий Пупкин!

 функция получает следующие аргументы:
	str 		– найденное совпадение,
	p1, p2, ..., pn – содержимое скобок (если есть),
	offset 		– позиция, на которой найдено совпадение,
	s – исходная строка.


 regexp.test(str)	- проверяет, есть ли хоть одно совпадение в строке str.
			  Возвращает true/false.
			  Работает, по сути, так же, как и проверка str.search(reg) != -1

			 	/лю/i.test(str) 		// true
				str.search(/лю/i != -1  	// true

 regexp.exec(str)	- позволяет искать и все совпадения и скобочные группы в них.

			  Если флага g нет, 	то regexp.exec(str) ищет и возвращает первое совпадение,
						является полным аналогом вызова str.match(reg).

			  Если флаг g есть, 	то вызов regexp.exec возвращает первое совпадение 
						и запоминает СЛЕДУЮЩУЮ за ПОСЛЕДНИМ СИМВОЛОМ СОВПАДЕНИЯ позицию
							в свойстве regexp.lastIndex.
						Последующий поиск он начнёт уже с этой позиции. 
						Если совпадений не найдено, то сбрасывает regexp.lastIndex в 0.
 ---------------------------------------------------------------
 ---- Классы --------------------------------------------------- 
 \d 	- Цифра, символ от 0 до 9.							[0-9]
 \s 	- Пробельный символ, включая табы, переводы строки и т.п.			[\t\n\v\f\r ] + 
 \w 	- буква латинского алфавита или цифра или подчёркивание '_'. 			[a-zA-Z0-9_]
	  Не-английские буквы не являются \w, то есть русская буква не подходит.

 \b 	- обозначает не символ, а границу между символами.

 \D	- Не-цифра, то есть любой символ кроме \d, например буква.
 \S	- Не-пробел, то есть любой символ кроме \s, например буква.
 \W	- Любой символ, кроме \w, то есть не латинница, не подчёркивание, не цифра.
	  В частности, русские буквы принадлежат этому классу.
 \B	- Проверка, обратная \b.

 . 	- точуа обозначает любой символ, кроме перевода строки
 ---------------------------------------------------------------

 ---- Жадный поиск 	/".+"/ 	    a "witch" and her "broom" is one	// "witch" and her "broom"

 ---- Ленивый поиск	/".+?"/g    a "witch" and her "broom" is one	// "witch" ,"broom"

 В жадном режиме (по умолчанию) регэксп повторяет квантификатор настолько много раз, 
 насколько это возможно, чтобы найти соответствие.
	
 Ленивый режим работы квантификаторов – «повторять минимальное количество раз».
 Его можно включить, если поставить знак вопроса '?' после квантификатора.
 Ленивость распространяется только на тот квантификатор, после которого стоит ?.

 ---- Скобочные группы		(...)
	Скобочную группу можно исключить из запоминаемых и нумеруемых, добавив в её начало ?:.

 ---- Обратные ссылки: \n и $n

 ---- ---- Группа в строке замены
 Ссылки в строке замены имеют вид $n, где n – это номер скобочной группы.
 Вместо $n подставляется содержимое соответствующей скобки:

 	var name = "Александр Пушкин";
	name = name.replace(/([а-яё]+) ([а-яё]+)/i, "$2, $1");
	alert( name ); // Пушкин, Александр

 ---- ---- Группа в шаблоне

	var str = "He said: \"She's the one!\".";

	var reg = /(['"])(.*?)\1/g;
	
	alert( str.match(reg) ); // "She's the one!"

	Теперь работает верно! Движок регулярных выражений, найдя первое скобочное выражение – кавычку (['"]),
	запоминает его и далее \1 означает «найти то же самое, что в первой скобочной группе».

 Чтобы использовать скобочную группу в строке замены – нужно использовать ссылку вида $1,
 а в шаблоне – обратный слэш: \1.

 Чтобы в принципе иметь возможность обратиться к скобочной группе – не важно откуда,
 она не должна быть исключена из запоминаемых при помощи ?:.
 Скобочные группы вида (?:...) не участвуют в нумерации.

 ---- Альтернация (или) "|"	 символом вертикальной черты |
 Для указания границ альтернации используют скобки (...), 
 например: before(XXX|YYY)after будет искать beforeXXXafter или beforeYYYafter.

 ---- Якоря "^", "$"

 	Якоря являются не символами, а проверками.

  ^ совпадает в начале текста
  $ – в конце.

	// без каретки найдёт все числа:
	var str = '100500 попугаев съели 500100 бананов!';
	alert( str.match(/\d+/ig) ); // 100500, 500100 (нашло все числа)

	// А с кареткой – только первое:
	var str = '100500 попугаев съели 500100 бананов!';
	alert( str.match(/^\d+/ig) ); // 100500 (только в начале строки)

	// пример с долларом для поиска числа в конце:
	 var str = '100500 попугаев съели 500100';
	alert( str.match(/\d+$/ig) ); // 500100


 	// Оба якоря используют одновременно, если требуется, 
	// чтобы шаблон охватывал текст с начала и до конца. Обычно это требуется при валидации.
	// поиск дроби: \d+\.\d+
	var num = "ля-ля 12.34";
	alert( num.match(/^\d+\.\d+$/ig) ); // null, не дробь

	var num = "12.34";
	alert( num.match(/^\d+\.\d+$/ig) ); // 12.34, дробь!

 ---- Многострочный режим, флаг "m"

 	Многострочный режим включается, если у регэкспа есть флаг /m.
	В этом случае изменяется поведение ^ и $.
	В многострочном режиме якоря означают не только начало/конец текста, но и начало/конец строки.

 | 	// Начало строки ^
 |	var str = '1е место: Винни\n' +
 |  		  '2е место: Пятачок\n' +
 |  		  '33е место: Слонопотам';
 |
 |	alert( str.match(/^\d+/gm) ); // 1, 2, 33
 |	
 |	// // без флага /m было бы найдено только первое число:
 |
 |	alert( str.match(/^\d+/g) ); // 1

 |	// Конец строки $
 |	var str = '1е место: Винни\n' +
 |		  '2е место: Пятачок\n' +
 |		  '33е место: Слонопотам';
 |
 |	alert( str.match(/[а-я]+$/gim) ); // Винни,Пятачок,Слонопотам
 |
 |	// Без флага m якорь $ обозначал бы конец всего текста, и было бы найдено только последнее слово.


=================================================================================================================
==== Дата  =================================================================================
 new Date()
 new Date(milliseconds)		- с 1 января 1970 года GMT+0.

 new Date(year, month, date, hours, minutes, seconds, ms)

 ---- Получение компонентов даты
  в текущей временной зоне	UTC-варианты в зоне GMT+0

 getFullYear()			getUTCFullYear()
 getMonth()			getUTCMonth()
 getDate()			...
 getHours()
 getMinutes()
 getSeconds()
 getMilliseconds()

 getDay()			 getUTCDay()

 getTime()		- число миллисекунд, прошедших с 1 января 1970 года GMT+0
 getTimezoneOffset()	- Возвращает разницу между местным и UTC-временем, в минутах.

 ---- Установка компонентов даты

 setFullYear(year [, month, date])
 setMonth(month [, date])
 setDate(date)
 setHours(hour [, min, sec, ms])
 setMinutes(min [, sec, ms])
 setSeconds(sec [, ms])
 setMilliseconds(ms)
 setTime(milliseconds) (устанавливает всю дату по миллисекундам с 01.01.1970 UTC)
 
 Все они, кроме setTime(), обладают также UTC-вариантом, например: setUTCHours().

 ---- 
 performance.now()	- возвращает количество миллисекунд, прошедшее с начала загрузки страницы.
			  Причём именно с самого начала, до того, как загрузился HTML-файл, 
				если точнее – с момента выгрузки предыдущей страницы из памяти.

 console.time(метка) 	– включить внутренний хронометр браузера с меткой.
 console.timeEnd(метка) – выключить внутренний хронометр браузера с меткой и вывести результат.

 ---- Форматирование и вывод дат

 date.toLocaleString(локаль, опции), 	в котором можно задать много настроек.
					Он позволяет указать, какие параметры даты нужно вывести, и ряд настроек вывода,
					после чего интерпретатор сам сформирует строку.

 var date = new Date(2014, 11, 31, 12, 30, 0);

 var options = {
  era: 'long',
  year: 'numeric',
  month: 'long',
  day: 'numeric',
  weekday: 'long',
  timezone: 'UTC',
  hour: 'numeric',
  minute: 'numeric',
  second: 'numeric'
 };

 alert( date.toLocaleString("ru", options) ); // среда, 31 декабря 2014 г. н.э. 12:30:00
 alert( date.toLocaleString("en-US", options) ); // Wednesday, December 31, 2014 Anno Domini 12:30:00 PM

 ---- ---- Методы вывода без локализации:

 toString()	- возвращает дату целиком
 toDateString()	- только дату
 toTimeString()	- только время

 toUTCString()	- То же самое, что `toString()`, но дата в зоне UTC.
 toISOString()	- Возвращает дату в формате ISO

 ---- Разбор строки
 Date.parse	 YYYY-MM-DDTHH:mm:ss.sssZ

 var msUTC = Date.parse('2012-01-26T13:51:50.417Z'); 	// зона UTC
 alert( msUTC )						// 1327571510417 (число миллисекунд)

 ---- 
 Date.now() 	- возвращает дату сразу в виде миллисекунд.
		  Технически, он аналогичен вызову +new Date(), 
		  но в отличие от него не создаёт промежуточный объект даты,
		  а поэтому – во много раз быстрее.

============================================================================================
==== Функции ============================================================================================
 Функция без return считается возвращающей undefined . Вызов return без значения также возвращает undefine
 
 function say(){...}	// Объявление Function Declaration
 alert( say )		// say без () выведет код функции

 ---- копирование функции в переменную ---
 var func = say;
 func();
 ------------------------------------
 --- Объявление Function Expression ------
 var sayHi = function(person) {
	alert( "Привет, " + person );
 };
 sayHi('Вася');

 можно вызвать «на месте»: var a = (func(b){...}())
 ------------------------
 функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода


------------------------------
---- Рекурсия --------
 function pow(x, n) {
   if (n != 1) { // пока n != 1 сводить вычисление pow(x,n) к pow(x,n‐1)
     return x * pow(x, n ‐ 1);
   } else {
     return x;
   }
 }
 
 Рекурсия — это когда функция вызывает сама себя, как правило, с другими аргументами.

 --- Именованные функциональные выражения (Named Function Expression)
   var f  = function sayHi(...) { /* тело функции */ };
 NFE используется в первую очередь в тех ситуациях, когда функцию нужно передавать в другое место кода или перемещать из одной переменной в другую.

 ошибка: 
 	function f(n) { return n ? n * f(n ‐ 1) : 1; };
	var g = f;
	f = null;
	alert( g(5) ); // запуск функции с новым именем ‐ ошибка при выполнении!

 правильно:
	var f = function factorial(n) { return n ? n * factorial(n ‐ 1) : 1; };
	var g = f;
	f = null;
	alert( g(5) ); // 120, работает!
 
-------------------
------------
 
 fixNames 		- задействует массив arguments (рассмотренный в предыдущем пункте) для приема
			  переданной ей последовательности строк и возвращения всех этих строк в виде
			  одной строки
===============================================================================================================

==== Замыкания ========================================================

 Все переменные внутри функции – это свойства специального внутреннего объекта LexicalEnvironment

 При создании функция получает скрытое свойство [[Scope]], 
 которое ссылается на лексическое окружение, в котором она была создана.
 	| var a = 1;
	| function getFunc() {	var a = 2;
	|			var func = function() { alert(a); };
	| 			return func;
	| }
	| getFunc()(); // 2, из LexicalEnvironment функции getFunc

 При создании функции с использованием new Function, 
 её свойство [[Scope]] ссылается не на текущий LexicalEnvironment, а на window.
	| var a = 1;
	| function getFunc() {	var a = 2;
	|			var func = new Function('', 'alert(a)');
	|			return func;
	| }
	| getFunc()(); // 1, из window


 Замыкание – это функция вместе со всеми внешними переменными, которые ей доступны.
 То есть, замыкание – это функция + внешние переменные.

 «Понимать замыкания» в JavaScript означает понимать следующие вещи:

	1. Все переменные и параметры функций являются свойствами объекта переменных LexicalEnvironment.
	   Каждый запуск функции создает новый такой объект. На верхнем уровне им является «глобальный
	   объект», в браузере – window.
	
	2. При создании функция получает системное свойство [[Scope]], которое ссылается на
	   LexicalEnvironment, в котором она была создана.

	3. При вызове функции, куда бы её ни передали в коде – она будет искать переменные сначала у себя,
	   а затем во внешних LexicalEnvironment с места своего «рождения».

 ---- Приём проектирования «Модуль»
 (function() {		| Завернуть все содержимое в модуль (function(){ })
	...		| и запустить её ()
 })();


 
=======================================================================
==== Объекты =====================================================================================================

 ==== Методы ====

 var user = {
		name: 'Василий',

	  	// метод
		sayHi: function() {
		    alert( 'Привет!' );
		}
 };

 // Вызов
 user.sayHi();

 ==== this
 
 var user = {
  	name: 'Василий',

  	sayHi: function() {		| this объявленная внутри функции 
  	       alert( this.name );	| дает ссылку на объект, т.е
  	}				| в данном случае на user
 
	export: this			| this вне функции дает сылку на window
					
 };

 ---- ---- Итого про this

	Значение this устанавливается в зависимости от того, как вызвана функция:

	При вызове функции как метода: this = obj

		obj.func(...)    // this = obj
		obj["func"](...)

	При обычном вызове:

		func(...) // this = window (ES3) 
			  // this = undefined (ES5)

	В new:

	new func() // this = {} (новый объект)
	
	Явное указание:

		func.apply(context, args) // this = context (явная передача)
		func.call(context, arg1, arg2, ...)

 ====		Логическое преобразование

 Любой объект в логическом контексте – true, даже если это пустой массив [] или объект {}.

 if ({} && []) {}	// сработает

 ==== toString	Строковое преобразование



 var user = {
	firstName: 'Василий',

	toString: function() {
		  return 'Пользователь ' + this.firstName;
  	}
 };

 alert( user ); // [object Object]	 	если нет toString, в теле объекта
 alert( user );  // Пользователь Василий	если toString определен
	-------------------
 alert( [1, 2] ); 		// toString для массивов выводит список элементов "1,2"
 alert( new Date ); 		// toString для дат выводит дату в виде строки
 alert( function() {} );	// toString для функции выводит её код


 ==== valueOf	Численное преобразование 
 
 Для численного преобразования объекта используется метод valueOf, а если его нет – то toString:

var room = {
	  number: 777,

 	  valueOf: function() { return this.number; },
	  toString: function() { return this.number; }
 };

 alert( +room );  	// 777, вызвался valueOf
 delete room.valueOf; 	// valueOf удалён
 alert( +room );  	// 777, вызвался toString

 ---- ---- У большинства объектов нет valueOf
	У большинства встроенных объектов такого valueOf нет, 
	поэтому численное и строковое преобразования для них работают одинаково.

	Исключением является объект Date, который поддерживает оба типа преобразований:
	alert( new Date() ); 		// toString: Дата в виде читаемой строки
	alert( +new Date() ); 		// valueOf: кол-во миллисекунд, прошедших с 01.01.1970

 ==== Конструкторы 	new
 function Animal(name) {	// Можно без скобок -> var animal = new Animal;

var animal = new BigAnimal; 
  // this = {};

  // в this пишем свойства, методы
  this.name = name;
  this.canWalk = true;
  // return this;
 }

 var animal = new Animal("ёжик");	
 => animal = {
 	 name: "ёжик",
 	 canWalk: true
    }
 
 вызов return с объектом вернёт объект, 
 а с чем угодно, кроме объекта – возвратит, как обычно, this.

 ==== Дескрипторы	[ https://learn.javascript.ru/descriptors-getters-setters ]
 
 Object.defineProperty(obj, prop, descriptor)

	obj		- Объект, в котором объявляется свойство.
	prop		- Имя свойства, которое нужно объявить или модифицировать.
	descriptor	- Дескриптор – объект, который описывает поведение свойства.
		value 		– значение свойства, 
				  по умолчанию undefined
		writable	– значение свойства можно менять, если true. 
				  По умолчанию false.
		configurable 	– если true, то свойство можно удалять, 
				  а также менять его в дальнейшем при помощи новых вызовов defineProperty. 
				  По умолчанию false.
		enumerable 	– если true, то свойство просматривается в цикле for..in и методе Object.keys(). 
				  По умолчанию false.
		get 		– функция, которая возвращает значение свойства.
				  По умолчанию undefined.
		set 		– функция, которая записывает значение свойства. 
				  По умолчанию undefined.
 	Чтобы избежать конфликта, запрещено одновременно указывать значение value и функции get/set. 
	Либо значение, либо функции для его чтения-записи, одно из двух. 

	Также запрещено и не имеет смысла указывать writable при наличии get/set-функций.

	| var user = {};
	|
	| user.name = "Вася";			// 1. простое присваивание
	|
	| // 2. указание значения через дескриптор
	| Object.defineProperty(user, "name", { value: "Вася", 
						configurable: true,
						writable: true,
						enumerable: true });

	Для того, чтобы сделать свойство неизменяемым, изменим его флаги writable и configurable:
		"use strict";
		...
		writable: false, 	// запретить присвоение "user.name="
		configurable: false 	// запретить удаление "delete user.name"

 ---- get/set
	var user = {
	  	firstName: "Вася",
		surname: "Петров"
	}

	Object.defineProperty(user, "fullName", {
  		get: function() {
    		     	return this.firstName + ' ' + this.surname;
  		}
  		
		set: function(value) {
      		     	var split = value.split(' ');
      			this.firstName = split[0];
      			this.surname = split[1];
    		}
	});

	user.fullName = "Петя Иванов";
	alert( user.firstName ); // Петя
	alert( user.surname ); // Иванов

 ---- Указание get/set в литералах
	var user = {
	  	firstName: "Вася",
  		surname: "Петров",

  		get fullName() {
    			return this.firstName + ' ' + this.surname;
  		},

  		set fullName(value) {
    			var split = value.split(' ');
    			this.firstName = split[0];
    			this.surname = split[1];
  		}
	};

	alert( user.fullName ); 	// Вася Петров (из геттера)

	user.fullName = "Петя Иванов";
	alert( user.firstName ); 	// Петя  (поставил сеттер)
	alert( user.surname ); 		// Иванов (поставил сеттер)

 ---- Другие методы работы со свойствами

 Object.defineProperties(obj, descriptors)
	Позволяет объявить несколько свойств сразу

 Object.keys(obj), 
 Object.getOwnPropertyNames(obj)
	Возвращают массив – список свойств объекта.

	Object.keys 			возвращает только enumerable-свойства.
	Object.getOwnPropertyNames 	– возвращает все:

 Object.getOwnPropertyDescriptor(obj, prop)
	Возвращает дескриптор для свойства obj[prop]

 Object.preventExtensions(obj)
	Запрещает добавление свойств в объект.
 Object.seal(obj)
	Запрещает добавление и удаление свойств, все текущие свойства делает 
		configurable: false.
 Object.freeze(obj)
	Запрещает добавление, удаление и изменение свойств, все текущие свойства делает 
		configurable: false, 
		writable: false.
 Object.isExtensible(obj)
	Возвращает false, если добавление свойств объекта было запрещено вызовом метода Object.preventExtensions.
 Object.isSealed(obj)
	Возвращает true, если добавление и удаление свойств объекта запрещено, 
	и все текущие свойства являются configurable: false.
Object.isFrozen(obj)
Возвращает true, если добавление, удаление и изменение свойств объекта запрещено, и все текущие свойства являются configurable: false, writable: false.


 ---- Статические свойства
	function Article() {	
		Article.count++;
	}
	Article.count = 0; 			// статическое свойство-переменная
	Article.DEFAULT_FORMAT = "html"; 	// статическое свойство-константа

 ---- Статические методы
	 
 	function Article() {
	  	Article.count++;
		//...
	}
	Article.count = 0;
	
	Article.showCount = function() {	-| Статический метод
	  	alert( this.count ); 		 |
	}					 |
	
	// использование
	new Article();
	new Article();
	Article.showCount(); 			// 2

 ----
 ---- Метод call

 func.call(context, arg1, arg2, ...)
	Вызов func.call(context, a, b...) – то же, что обычный вызов func(a, b...), 
	но с явно указанным this(=context).

 |	//
 |	var user = {
 |  		firstName: "Василий",
 |  		surname: "Петров",
 |  		patronym: "Иванович"
 |	};
 |
 |	function showFullName(firstPart, lastPart) {
 |  		alert( this[firstPart] + " " + this[lastPart] );
 |	}
 |
 |	// f.call(контекст, аргумент1, аргумент2, ...)
 |	showFullName.call(user, 'firstName', 'surname') // "Василий Петров"
 |	showFullName.call(user, 'firstName', 'patronym') // "Василий Иванович"


 ---- ---- «Одалживание метода»
 |	//
 |	function printArgs() {
 |  		arguments.join = [].join; // одолжили метод.
 |					  // объявлен пустой массив [] и скопирован его метод [].join.
 |					  // Обратим внимание, мы не вызываем его, а просто копируем.
 |					  // Функция, в том числе встроенная – обычное значение, мы можем
 |					  // скопировать любое свойство любого объекта, и [].join 
 |					  // здесь не исключение.
 |
 |  		var argStr = arguments.join(':'); // запустили join в контексте arguments,
 |						  // как будто он всегда там был.
 |
 |		alert( argStr ); // сработает и выведет 1:2:3
 |	}
 |
 |	printArgs(1, 2, 3);
 -
 |	// с методом call
 |
 |	function printArgs() {
 |  		var join = [].join; // скопируем ссылку на функцию в переменную
 |
 |  		// вызовем join с this=arguments,
 |  		// этот вызов эквивалентен arguments.join(':') из примера выше
 |  		var argStr = join.call(arguments, ':');
 |
 |  		alert( argStr ); // сработает и выведет 1:2:3
 |	}
 |
 |	printArgs(1, 2, 3);	// Мы вызвали метод без копирования. Чисто, безопасно.
 -
 |	// простой способ сделать из arguments настоящий массив.
 |	
 |	function printArgs() {
 |  		// вызов arr.slice() скопирует все элементы из this в новый массив
 |  		var args = [].slice.call(arguments);
 |  		alert( args.join(', ') ); // args - полноценный массив из аргументов
 |	}
 |
 |	printArgs('Привет', 'мой', 'мир'); // Привет, мой, мир

 ---- Метод apply
 Если нам неизвестно, с каким количеством аргументов понадобится вызвать функцию,
 можно использовать более мощный метод: apply.

 Вызов функции при помощи func.apply работает аналогично func.call,
 но принимает массив аргументов вместо списка.

 func.call(context, arg1, arg2);	// идентичен вызову
 func.apply(context, [arg1, arg2]);	//

 Преимущество apply перед call отчётливо видно, когда мы формируем массив аргументов динамически.

 ---- Привязка контекста
 |	//
 |	var user = {
 |	  firstName: "Вася",
 |	  sayHi: function() {
 |	    alert( this.firstName );
 |	  }
 |	};
 |
 |	setTimeout(user.sayHi, 1000); // undefined (не Вася!)
 
 ---- ---- Решение 1: сделать обёртку
 
	setTimeout(function() {
	  user.sayHi(); // Вася
	}, 1000);
 А что, если до срабатывания setTimeout (ведь есть целая секунда)
 в переменную user будет записано другое значение?

 ---- ---- Решение 2: bind для привязки контекста
 	function bind(func, context) {
 	  return function() {
 	     return func.apply(context, arguments);
  	  };
	}

	var user = { ... };

	setTimeout(bind(user.sayHi, user), 1000);

 ---- ---- Решение 3: встроенный метод bind
	Синтаксис встроенного bind:
	var wrapper = func.bind(context[, arg1, arg2...])

		func		- Произвольная функция
		context		- Контекст, который привязывается к func
		arg1, arg2, …	- Если указаны аргументы arg1, arg2... – они будут прибавлены к каждому
				  вызову новой функции, причем встанут перед теми, 
				  которые указаны при вызове.

 	Результат вызова func.bind(context) аналогичен вызову bind(func, context), описанному выше. 
 То есть, wrapper – это обёртка, фиксирующая контекст и передающая вызовы в func. 
 Также можно указать аргументы, тогда и они будут фиксированы, 

 | 	//
 |	var user = { ... };
 |	
 |	setTimeout(user.sayHi.bind(user), 1000); // аналог через встроенный метод

 
|	bind не похож на call/apply
|
| Методы bind и call/apply близки по синтаксису, но есть важнейшее отличие.
| Методы call/apply вызывают функцию с заданным контекстом и аргументами.
| А bind не вызывает функцию. Он только возвращает «обёртку», которую мы можем вызвать позже,
| и которая передаст вызов в исходную функцию, с привязанным контекстом.

==================================================================================================================
==== JSON =================================================================================
 ---- Методы ----
 JSON.parse 	– читает объекты из строки в формате JSON.
 JSON.stringify – превращает объекты в строку в формате JSON, 
		  используется, когда нужно из JavaScript передать данные по сети.
 ----------------

 ---- JSON.parse(str) превратит строку с данными в формате JSON в JavaScript-объект/массив/значение.
	var user = '{ "name": "Вася", "age": 35, "isAdmin": false, "friends": [0,1,2,3] }';
	user = JSON.parse(user);
	alert( user.friends[1] ); // 1

 ---- ---- JSON.parse(str, reviver) 	// reviver = function(key, value).
	 var schedule = '{ \
	  "events": [ \
	    {"title":"Конференция","date":"2014-11-30T12:00:00.000Z"}, \
	    {"title":"День рождения","date":"2015-04-18T12:00:00.000Z"} \
	  ]\
	}';
	
	schedule = JSON.parse(schedule, function(key, value) {
	  if (key == 'date') return new Date(value);
	  return value;
	});
	
	alert( schedule.events[1].date.getDate() ); // сработает!

 ---- JSON.stringify(value, replacer, space) преобразует («сериализует») значение в JSON-строку.
 I.	var event = {
	  title: "Конференция",
	  date: "сегодня"
	};

	var str = JSON.stringify(event);
	alert( str ); // {"title":"Конференция","date":"сегодня"}

	// Обратное преобразование.
	event = JSON.parse(str);

 II.	JSON.stringify(value, replacer):
	var user = {
	  name: "Вася",
	  age: 25,
	  window: window
	};
	
	alert( JSON.stringify(user, ["name", "age"]) );
	// {"name":"Вася","age":25}

 III. JSON.stringify(value, replacer, space) 

	параметр space - Если он является числом – то уровни вложенности в JSON оформляются указанным
			 количеством пробелов, если строкой – вставляется эта строка.
	var user = {
	  name: "Вася",
	  age: 25,
	  roles: {
	    isAdmin: false,
	    isEditor: true
	  }
	};
	
	var str = JSON.stringify(user, "", 4);
	
	alert( str );
	/* Результат -- красиво сериализованный объект:
	{
	    "name": "Вася",
	    "age": 25,
	    "roles": {
	        "isAdmin": false,
	        "isEditor": true
	    }
	}
	*/	
		
===========================================================================================
==== Таймер == timer ======================================================================
	setTimeout 	setInterval	// var timerId = setTimeout(func / code, delay[, arg1, arg2...])
	clearTimeout	clearInterval	// clearTimeout(timerId);

 ---- Рекурсивный setTimeout

 	Важная альтернатива setInterval – рекурсивный setTimeout

	/** вместо:
		var timerId = setInterval(function() {
		  alert( "тик" );
		}, 2000);
	*/

		var timerId = setTimeout(function tick() {
		  alert( "тик" );
		  timerId = setTimeout(tick, 2000);
		}, 2000);

===========================================================================================
==== ошибки ---- try{} catch{} ============================================================

 try 	  {	.. пробуем выполнить код .. 	} 
 catch(e) {	.. перехватываем исключение .. 	} 
 finally  {	.. выполняем всегда ..		}

 -----------------------------------------------
 .name		- Тип ошибки. 
		  Например, при обращении к несуществующей переменной: "ReferenceError".
 .message	- Текстовое сообщение о деталях ошибки.
 .stack		- Везде, кроме IE8-, есть также свойство stack, которое содержит строку с информацией о
		  последовательности вызовов, которая привела к ошибке.

 ---- оператор throw
 SyntaxError, ReferenceError, RangeError

 if (!user.name) {
    throw new SyntaxError("Данные некорректны");
  }

 ---- ---- проброс исключения
 function readData() {
  	var data = '{ "name": "Вася", "age": 30 }';

  	try {
    		// ...
    		blabla(); // ошибка!
  	} catch (e) {
    		// ...
    		if (e.name != 'SyntaxError') {
      			throw e; 		// пробрасываем
    		}
  	}
  }

 try {
  	readData();
 } catch (e) {
  	alert( "Поймал во внешнем catch: " + e ); // ловим
 }

 ---- ---- Оборачивание исключений
 function ReadError(message, cause) {
  	this.message = message;
  	this.cause = cause;
  	this.name = 'ReadError';
  	this.stack = cause.stack;
 }

 function readData() {
  	var data = '{ bad data }';

  	try {
    		// ...
    		JSON.parse(data);
    		// ...
  	} catch (e) {
    		// ...
    		if (e.name == 'URIError') {
      			throw new ReadError("Ошибка в URI", e);
    		} else if (e.name == 'SyntaxError') {
      			throw new ReadError("Синтаксическая ошибка в данных", e);
    		} else {
      			throw e; // пробрасываем
    		}
  	}
 }

 try {
  	readData();
 } catch (e) {
  	if (e.name == 'ReadError') {
    		alert( e.message );
    		alert( e.cause ); // оригинальная ошибка-причина
  	} else {
    		throw e;
  	}
 }
 
 ---- ---- Ловим ошибку
 window.onerror = function(message, url, lineNumber) {
    alert("Поймана ошибка, выпавшая в глобальную область!\n" +
      "Сообщение: " + message + "\n(" + url + ":" + lineNumber + ")");
  };
===========================================================================================
==== ООП ==================================================================================
==== ООП в функциональном стиле ====
 function CoffeeMachine(power) {			// power - приватное св-во
    var waterAmount = 0;

	---- геттер и сеттер ----------
  this.waterAmount = function(amount) {
    // вызов без параметра, значит режим геттера, возвращаем свойство
    if (!arguments.length) return waterAmount;

    // иначе режим сеттера
    if (amount < 0) {
      throw new Error("Значение должно быть положительным");
    }
    if (amount > capacity) {
      throw new Error("Нельзя залить воды больше, чем " + capacity);
    }

    waterAmount = amount;
  };
}

 ---- ---- Функциональное наследование
 Организация наследования, которая описана в этой главе, называется «функциональным паттерном наследования».

 	Её общая схема (кратко):

	Объявляется конструктор родителя Machine. 
 В нём могут быть приватные (private), 
		  публичные (public) и 
		  защищённые (protected) свойства:

 function Machine(params) {
  	var privateProperty;		// локальные переменные и функции доступны только внутри Machine
	this.publicProperty = ...;	// публичные доступны снаружи

	this._protectedProperty = ...   // защищённые доступны внутри Machine и для потомков
  					// мы договариваемся не трогать их снаружи	
 }

 var machine = new Machine(...)
 machine.public();

	Для наследования конструктор потомка вызывает родителя в своём контексте через apply. 
	После чего может добавить свои переменные и методы:

 function CoffeeMachine(params) {
    Machine.apply(this, arguments);		// универсальный вызов с передачей любых аргументов

    this.coffeePublicProperty = ...
}

 var coffeeMachine = new CoffeeMachine(...);
 coffeeMachine.publicProperty();
 coffeeMachine.coffeePublicProperty();

	В CoffeeMachine свойства, полученные от родителя, можно перезаписать своими. 
Но обычно требуется не заменить, а расширить метод родителя. Для этого он предварительно копируется в переменную:

 function CoffeeMachine(params) {
  	Machine.apply(this, arguments);

  	var parentProtected = this._protectedProperty;
  	this._protectedProperty = function(args) {
    		parentProtected.apply(this, args); // (*)
    		// ...
  	};
 }
	Строку (*) можно упростить до parentProtected(args), 
если метод родителя не использует this, а, например, привязан к var self = this:

 function Machine(params) {
  	var self = this;

  	this._protected = function() { self.property = "value"; };
 }

	Надо сказать, что способ наследования, описанный в этой главе, используется нечасто.

---------------------------------------

 ==== ООП в прототипном стиле ==============================================================
 ==== __proto__ 
	Если один объект имеет специальную ссылку __proto__ на другой объект,
	то при чтении свойства из него, если свойство отсутствует в самом объекте, оно ищется в объекте __proto__.

  var animal = 	{  eats: true	};
  var rabbit = 	{  jumps: true	};

  rabbit.__proto__ = animal;

	// в rabbit можно найти оба свойства
  alert( rabbit.jumps ); // true
  alert( rabbit.eats ); // true

 ====
 obj.hasOwnProperty(prop) 	- true, если свойство prop принадлежит самому объекту obj, иначе false.

  var animal = 	{  eats: true	};
  var rabbit = 	{  jumps: true,	__proto__: animal };

  alert( rabbit.hasOwnProperty('jumps') ); // true: jumps принадлежит rabbit
  alert( rabbit.hasOwnProperty('eats') ); // false: eats не принадлежит


 	Для того, чтобы перебрать свойства самого объекта, достаточно профильтровать key через hasOwnProperty:

  var animal = 	{  eats: true	};
  var rabbit = 	{  jumps: true,	__proto__: animal };

  for (var key in rabbit) {
    if (!rabbit.hasOwnProperty(key)) continue; // пропустить "не свои" свойства

    alert( key + " = " + rabbit[key] ); // выводит только "jumps"
  }

 ---- Object.create(null) не имеет прототипа, а значит в нём нет лишних свойств. Для коллекции – как раз то, что надо.
  var data = Object.create(null);
  data.text = "Привет";

  alert(data.text); // Привет
  alert(data.toString); // undefined

 ---- Методы для работы с proto
 
  Чтение: 		Object.getPrototypeOf(obj)		Возвращает obj.__proto__ (кроме IE8-)
  Запись: 		Object.setPrototypeOf(obj, proto)	Устанавливает obj.__proto__ = proto (кроме IE10-).
  Создание объекта 
  с прототипом: 	Object.create(proto, descriptors)
				Создаёт пустой объект с __proto__, равным первому аргументу (кроме IE8-),
				второй необязательный аргумент может содержать дескрипторы свойств.

 ---- F.prototype
 I. Недостаток этого подхода – он не работает в IE10-.

  var animal = 	{  eats: true };

  function Rabbit(name) {  this.name = name;
			   this.__proto__ = animal;
  }

  var rabbit = new Rabbit("Кроль");
  alert( rabbit.eats ); // true, из прототипа		

 II. работает всегда и везде:

  var animal = { eats: true };

  function Rabbit(name) { this.name = name; }

  Rabbit.prototype = animal;
  var rabbit = new Rabbit("Кроль"); //  rabbit.__proto__ == animal

  alert( rabbit.eats ); // true

  Установка Rabbit.prototype = animal буквально говорит интерпретатору следующее:
  "При создании объекта через new Rabbit запиши ему __proto__ = animal".

 ---- constructor
	У каждой функции по умолчанию уже есть свойство prototype.
	Оно содержит объект такого вида:

	function Rabbit() {}
	Rabbit.prototype = { constructor: Rabbit };

 ==== классы
 ---- Object.prototype
	var obj = {};

	// метод берётся из прототипа?
	obj.toString == Object.prototype.toString 	// true, да

	// проверим, правда ли что __proto__ это Object.prototype?
	obj.__proto__ == Object.prototype		// true

	// А есть ли __proto__ у Object.prototype?
	obj.__proto__.__proto__				// null, нет

 ---- Встроенные «классы»	-> Array.prototype, Function.prototype и т.п.

 Array.prototype.__proto__, равная Object.prototype
 

 ---- Свои классы на прототипах

	|- Обычный конструктор	-|			||	|- Класс через прототип	-|
							||
 function Animal(name) {				|| function Animal(name) {	// конструктор
  this.speed = 0;					||  this.speed = 0;
  this.name = name;					||  this.name = name;
							|| }
  this.run = function(speed) {				||	// методы в прототипе
    this.speed += speed;				|| Animal.prototype.run = function(speed) {
    alert( this.name + 'бежит, скорость'+this.speed);	||   this.speed += speed;
  };							||   alert( this.name + ' бежит, скорость ' + this.speed );
							|| };
  this.stop = function() {				||
    this.speed = 0;					|| Animal.prototype.stop = function() {
    alert( this.name + ' стоит' );			||  this.speed = 0;
  };							||  alert( this.name + ' стоит' );
 };							|| };
							||
 var animal = new Animal('Зверь');			|| var animal = new Animal('Зверь');
							||
 alert( animal.speed ); // 0, начальная скорость	|| alert( animal.speed ); // 0, свойство взято из прототипа
 animal.run(3); // Зверь бежит, скорость 3		|| animal.run(5); // Зверь бежит, скорость 5
 animal.run(10); // Зверь бежит, скорость 13		|| animal.run(5); // Зверь бежит, скорость 10
 animal.stop(); // Зверь стоит				|| animal.stop(); // Зверь стоит

 	Сравнение	Чем такое задание класса лучше и хуже функционального стиля?

	Достоинства
  Функциональный стиль записывает в каждый объект и свойства и методы, а прототипный – только свойства.
  Поэтому прототипный стиль – быстрее и экономнее по памяти.
	Недостатки
  При создании методов через прототип, мы теряем возможность использовать локальные переменные 
  как приватные свойства, у них больше нет общей области видимости с конструктором.
 

 -- class es6
class Animal {
    constructor(name) {
        this.name = name;
        this.thirst = 100;
        this.belly = [];
    }
    drink() { ... }
}
const rhino = new Animal("Rhino");
 -- -- наследование --
class Dog extends Animal {
    constructor(name, breed) {
        super(name);			// берется name от Animals, т.е. this.name = name
        this.breed = breed;
     }
    bark() { ... }
}
 ==== Наследование
 I.
 Rabbit.prototype.__proto__ = Animal.prototype;		- IE10-

 II.
 Rabbit.prototype = Object.create(Animal.prototype);	- Object.create - либо встроена либо легко 
									  эмулируется во всех браузерах.
 Rabbit.prototype.constructor = Rabbit;			- нужно явно сохранить конструктов

 ---- Вызов конструктора родителя
 function Animal(name) { this.name = name; this.speed = 0; }
 function Rabbit(name) { this.name = name; this.speed = 0; }

 function Rabbit(name) {		-| Такой вызов запустит функцию Animal в контексте текущего объекта,
  Animal.apply(this, arguments);	 |  со всеми аргументами, она выполнится и запишет в this всё, что нужно.
 }
 

 ---- Вызов метода родителя внутри своего

 Rabbit.prototype.run = function() {				
   Animal.prototype.run.apply(this, arguments);		- вызвать метод родителя, передав ему текущие аргументы
   this.jump();						- назначить дополнительные параметры к Rabbit.run
  }

 ~~~~~~~~~~ Структура наследования полностью:
 
// --------- Класс-Родитель ------------
// Конструктор родителя пишет свойства конкретного объекта
function Animal(name) {
  this.name = name;
  this.speed = 0;
}

// Методы хранятся в прототипе
Animal.prototype.run = function() {
  alert(this.name + " бежит!")
}

// --------- Класс-потомок -----------
// Конструктор потомка
function Rabbit(name) {
  Animal.apply(this, arguments);
}

// Унаследовать
Rabbit.prototype = Object.create(Animal.prototype);

// Желательно и constructor сохранить
Rabbit.prototype.constructor = Rabbit;

// Методы потомка
Rabbit.prototype.run = function() {
  // Вызов метода родителя внутри своего
  Animal.prototype.run.apply(this);
  alert( this.name + " подпрыгивает!" );
};

// Готово, можно создавать объекты
var rabbit = new Rabbit('Кроль');
rabbit.run();
 
============================================================================================
===== AJAX =================================================================================
 var request = new XMLHttpRequest(); var xhr = new XMLHttpRequest();
 request.

 ---- Запрос -------------------
 .open(method, URL, async, user, password)
			  	- Определение используемого HTTP-метода (GET или POST)
				  URL-адрес запроса(не только http/https,но ftp:// и file://)
				  async – если false - синхронно, если true – асинхронно.
				  user, password – логин и пароль для HTTP-авторизации, 
					если нужны.
 .send(данные) 	- Отправка данных серверу назначения с использованием
				  указанного HTTP-метода
 .abort() 		- Отмена текущего запроса

 -------------------------------
 ---- Ответ --------------------
 .status 			- Код статуса HTTP, возвращенный сервером
				  != 200 - ошибка
				  0, если сервер не ответил или при запросе на другой домен.

 .statusText 			- Текст статуса HTTP, возвращенный сервером
 .responseText 			- Данные, возвращенные сервером в текстовом формате
 .responseXML 			- Данные, возвращенные сервером в формате XML

 -------------------------------
 .onreadystatechange	- Определяет функцию обработки события, вызываемую при
				  		  изменении имеющегося в объекте свойства readyState
 .readyState 	- Целочисленное свойство, 
				  дающее представление о состоянии запроса. 
				  0 = неинициализирован	// начальное состояние
				  1 = загружается	// вызван open
				  2 = загружен		// получены заголовки
				  3 = в состоянии диалога
			// загружается тело (получен очередной пакет данных)
				  4 = завершен		// запрос завершён
 -------------------------------
 ---- HTTP-заголовки -----------
 .setRequestHeader(name, value)	- Устанавливает заголовок name запроса со значением value.
			request.setRequestHeader('Content-Type', 'application/json');

 .getResponseHeader(name)	- Возвращает значение заголовка ответа name, 
				  кроме Set-Cookie и Set-Cookie2.
				  request.getResponseHeader('Content-Type')
 .getAllResponseHeaders()	- Возвращает все заголовки ответа, 
				  кроме Set-Cookie и Set-Cookie2.

	Заголовки возвращаются в виде единой строки, например:
		Cache-Control: max-age=31536000
		Content-Length: 4260
		Content-Type: image/png
		Date: Sat, 08 Sep 2012 16:53:16 GMT
 -------------------------------
 ---- Таймаут ------------------
 .timeout = 30000		- Максимальную продолжительность асинхронного запроса

 При превышении этого времени запрос будет оборван и сгенерировано событие ontimeout:
 request.ontimeout = function() { alert( 'Извините, запрос превысил максимальное время' ); }
 -------------------------------
 -------------------------------
 .withCredentials = true;	- Чтобы браузер передал вместе с запросом куки и 
				  HTTP-авторизацию
 -------------------------------
 ---- Полный список событий ---- исп-ть "on" (onprogress)
 loadstart 			– запрос начат.
 progress 			– браузер получил очередной пакет данных, можно прочитать
				  текущие полученные  данные в responseText.
 				  Представляет собой объект типа ProgressEvent:
 | loaded			- Сколько байт уже переслано.
 | lengthComputable		- Если true, то известно полное количество байт для
				   пересылки, и оно хранится в свойстве total.
 | total			- Общее количество байт для пересылки, если известно.


 abort 				– запрос был отменён вызовом xhr.abort().
 error 				– произошла ошибка.
 load 				– запрос был успешно (без ошибок) завершён.
 timeout 			– запрос был прекращён по таймауту.
 loadend 			– запрос был завершён (успешно или неуспешно)
 ------------------------------- https://learn.javascript.ru/ajax-xmlhttprequest -----------
 Типовой код для GET-запроса при помощи XMLHttpRequest:
 var xhr = new XMLHttpRequest();
 xhr.open('GET', '/my/url', true);
 xhr.send();
 xhr.onreadystatechange = function() {
  	if (this.readyState != 4) return;
  
  	// по окончании запроса доступны:
  	// status, statusText
  	// responseText, responseXML (при content-type: text/xml)
	
	if (this.status != 200) {
	    // обработать ошибку
	    alert( 'ошибка: ' + (this.status ? this.statusText : 'запрос не удался') );
	    return;
	}
	
	// получить результат из this.responseText или this.responseXML
 }
 -------------------------------
 ------------------------------- https://learn.javascript.ru/xhr-forms ------------------
 encodeURIComponent(str)	- получения UTF-8 кодировки 
				  encodeURIComponent('В') ; // %D0%92

 У форм есть две основные кодировки: 
 application/x-www-form-urlencoded 	– по умолчанию и 
 multipart/form-data 			– для POST запросов, если явно указана в enctype.
 Вторая кодировка обычно используется для больших данных и только для тела запроса.

 Для составления запроса в 
 application/x-www-form-urlencoded 	используется функция encodeURIComponent.

 Для отправки запроса в 
 multipart/form-data 			– объект FormData.

 Для обмена данными JS ↔ сервер можно использовать и просто JSON, 
 желательно с указанием кодировки в заголовке Content-Type.

 В XMLHttpRequest можно использовать и другие HTTP-методы, 
 например PUT, DELETE, TRACE. К ним применимы все те же принципы, что описаны выше.

 Простой метод: GET, POST или HEAD

 Простые заголовки – только из списка:
	Accept
	Accept-Language
	Content-Language
	Content-Type со значением:
		application/x-www-form-urlencoded
		multipart/form-data 
		text/plain.

 ---- Стадия закачки 
 xhr.upload 	- объектдля получения информации используем. 
		  У этого объекта нет методов.
		  Он только генерирует события в процессе закачки
 -----------------
 xhr.upload.onprogress = function(event) {
   alert( 'Загружено на сервер ' + event.loaded + ' байт из ' + event.total );
 }
 xhr.upload.onload = function() {
   alert( 'Данные полностью загружены на сервер!' );
 }
 xhr.upload.onerror = function() {
   alert( 'Произошла ошибка при загрузке данных на сервер!' );
 }
 ------------------
 ---- Стадия скачивания
  xhr.onprogress = function(event) {
   alert( 'Получено с сервера ' + event.loaded + ' байт из ' + event.total );
 }
 -------------------
 ---- черновик
 Обработчик xhr.onprogress даёт прогресс на фазе скачивания, 
	а после неё наступает фаза закачки, для которой работает xhr.upload.onprogress.

 сначала формируется запрос и происходит загрузка на сервер, 
	после когда загрузка завершена, формируется ответ и отправляется клиенту. 

 получается следующая последовательность событий:

   xhr.onloadstart	->	xhr.upload.onloadstart		-> xhr.upload.onprogress -> ...
-> xhr.upload.onprogress->	xhr.unpload.onload		-> xhr.unpload.onloadend ->
-> xhr.onprogress 	->	... 				-> xhr.onprogress
-> xhr.onload		->	xhr.onloadend
=================================================================================================================

----
console.log 	- выводит элемент в виде, удобном для исследования HTML-структуры.
console.dir 	- выводит элемент в виде JavaScript-объекта, удобно для анализа его свойств.
---------
==== DOM ========================

 ==== Ссылки ======================

 document.documentElement		- Элемент <HTML>
 document.body				- Элемент <BODY>
 document.head				- Элемент <HEAD> (IE9+)

 По всем узлам:
		parentNode

		nextSibling 
		previousSibling

		childNodes 
		firstChild 
		lastChild

 Только по элементам:
		parentElement

		nextElementSibling 
		previousElementSibling

		children
		firstElementChild 
		lastElementChild
 
 для таблиц:
		table.rows[N]		- строка TR номер N.
		tr.cells[N]		- ячейка TH/TD номер N.
		tr.sectionRowIndex	- номер строки в таблице в секции THEAD/TBODY.
		td.cellIndex		- номер ячейки в строке.

 ==== Поиск ==================== Выборка

 elem.querySelector("css")				-По селектору, только первый элемент
 document.querySelectorAll('ul > li:last-child')	-| псевдомассив
         .querySelector('[data-placeholder]')		 | поиск по атрибуту

 document.getElementById("идентификатор")

 parent.getElementsByTagName(tag)			-> коллекция, список
 document.getElementsByName('age')
 parent.getElementsByClassName('className')		-> коллеция

 
 elem.matches(css) 		// true/false удовлетворяет ли elem селектору css
	var elems = document.body.children;
	for (var i = 0; i < elems.length; i++) { 
		if (elems[i].matches('a[href$="zip"]')) { alert( "Ссылка на архив: " + elems[i].href );}
	}


 elem.closest(css) 		ищет ближайший элемент выше по иерархии DOM, подходящий под CSS-селектор css.
				Первым проверяется сам elem. Этот элемент возвращается.
	  var numberSpan = document.querySelector('.num');

	  	// ближайший элемент сверху подходящий под селектор li
	  alert(numberSpan.closest('li').className) // subchapter

	 	// ближайший элемент сверху подходящий под селектор .chapter
	  alert(numberSpan.closest('.chapter').tagName) // LI

	  	// ближайший элемент сверху, подходящий под селектор span
	  	// это сам numberSpan, так как поиск включает в себя сам элемент
	  alert(numberSpan.closest('span') === numberSpan) // true



 elemA.contains(elemB)			- Возвращает true, если elemA является предком (содержит) elemB.
 var result = parent.contains(child)	-  true, если parent содержит child или parent == child.

 elemA.compareDocumentPosition(elemB)	- Возвращает битовую маску, которая включает в себя отношение
					  вложенности между elemA и elemB, а также – какой из элементов
					  появляется в DOM первым.


 ==== Основные свойства DOM-узлов: =============

 node.nodeType		- Тип узла."1" – для элементов,"3" – для текстовых узлов. Только для чтения.
 elem.nodeName/tagName 	- Название тега заглавными буквами. 
		    	nodeName имеет специальные значения для узлов-неэлементов. Только для чтения.

 elem.innerHTML: содержимое элемента	- Внутреннее содержимое узла-элемента в виде HTML. Можно изменять.
	 document.body.innerHTML = 'New BODY!';

 .outerHTML: HTML элемента целиком
	 var div = document.body.children[0];
	 div.outerHTML = '<p>Новый элемент!</p>';
	 При записи в elem.outerHTML переменная elem сохраняет старый узел.

 node.nodeValue/data: содержимое текстового узла (Содержимое узла любого типа, кроме элемента)
	for (var i = 0; i < document.body.childNodes.length; i++) { 
		alert( document.body.childNodes[i].data );
	}
	Содержимое текстового узла или комментария. Свойство nodeValue также определено и для других типов узлов. Можно изменять. На некоторых узлах, где data нет, nodeValue есть и имеет значение null, поэтому лучше использовать data.


 node.textContent	- Текстовое содержимое узла, для элементов содержит текст с вырезанными тегами.

 
 elem.hidden	var lastDiv = document.body.children[2]; lastDiv.hidden = true;

 ==== Атрибуты и DOM-свойства =========

    elem.hasAttribute("name") 		– проверяет наличие атрибута	проверка наличия
	.getAttribute("name") 		– получает значение атрибута	чтение
	.setAttribute(name, value) 	– устанавливает атрибут		запись
	.removeAttribute(name) 		– удаляет атрибут
  elem.attributes - все атрибуты элемента (псевдо-массив объектов типа Attr)
	Коллекция attributes содержит все атрибуты в виде объектов со свойствами name и value.
 
 input.getAttribute('value') хранит оригинальное (исходное) значение даже после того, как пользователь заполнил поле и свойство изменилось.
 -------------------------------------------------------------------------------------------------------
 
 --- dataset, data-атрибуты -----

 elem.dataset.*				- Значения атрибутов вида data-*
	
 <div id="elem" data-about="Elephant" data-user-location="street">
  По улице прошёлся слон. Весьма красив и толст был он.
 </div>

 // обращение как атрибутам
	<script>
	  alert( elem.getAttribute('data-about') ); // Elephant
	  alert( elem.getAttribute('data-user-location') ); // street
	</script>

 // обращение как свойствам
	<script>
	  alert( elem.dataset.about ); // Elephant
	  alert( elem.dataset.userLocation ); // street
	</script>
 -------------------
 Атрибуты – это то, что написано в HTML.
 Свойство – это то, что находится в свойстве DOM-объекта.

 Свойства:				Атрибуты:
	Любое значение				Строка
	Названия регистрозависимы		Не чувствительны к регистру
	Не видны в innerHTML			Видны в innerHTML


 ==== Изменение =========================

 --- Создание элемента
 document.createElement("tag")	- Создает новый элемент с указанным тегом
				  var div = document.createElement('div');
 	 .createTextNode("text")	- Создает новый *текстовый* узел с данным текстом
				  var textElem = document.createTextNode('Тут был я');

 --- Клонирование узлов: cloneNode
 var div2 = div.cloneNode(deep) 	- div клонируется в div2, если deep == true, то со всеми потомками,
									 если false – без потомков. 

 --- Добавление элемента: var parent = document.body;

 parent.appendChild(newChild)			- Добавляет newChild в конец дочерних элементов parent.
       .removeChild(child)			- Удаляет child из списка детей parent

       .insertBefore(newChild, refNode)		- Вставляет newChild в коллекцию детей parent, 
						  перед элементом refNode.
       .replaceChild(newElem, elem)	- Среди детей parent удаляет elem и вставляет на его место newElem.
 elem.remove()				- который удаляет элемент напрямую, не требуя ссылки на родителя

 parent.insertAdjacentHTML("beforeBegin
				|afterBegin
				|beforeEnd
				|afterEnd", html)
 parent.insertAdjacentElement("beforeBegin|...|afterEnd", text) (кроме FF)
 parent.insertAdjacentText("beforeBegin|...|afterEnd", text) (кроме FF)
 document.write(...)

 
 
 ---- Добавление множества узлов
 ---- insertAdjacent*

 insertAdjacentHTML	- позволяет вставлять произвольный HTML в любое место документа,
			  в том числе и между узлами!
 elem.insertAdjacentHTML(where, html); 
	html	- Строка HTML, которую нужно вставить
	where 	- Куда по отношению к elem вставлять строку. Всего четыре варианта:	
		  1. `beforeBegin` -- перед `elem`.
		  2. `afterBegin` -- внутрь `elem`, в самое начало.
		  3. `beforeEnd` -- внутрь `elem`, в конец.
		  4. `afterEnd` -- после `elem`.

 elem.insertAdjacentElement(where, newElem) – вставляет не строку HTML, а элемент newElem.
     .insertAdjacentText(where, text) 	    – создаёт текстовый узел из строки text и вставляет его 

 --- DocumentFragment
     когда DocumentFragment вставляется в DOM – то он исчезает, а вместо него вставляются его дети

 var fragment = document.createDocumentFragment();

 fragment.appendChild(node);	// В него можно добавлять другие узлы.
 fragment.cloneNode(true);	// Его можно клонировать
 
 --- методы, которые позволяют вставить что угодно и куда угодно.
 
 node.append(...nodes) 		– вставляет nodes в конец node,			 ____before_____
 node.prepend(...nodes)		– вставляет nodes в начало node,		|   prepend	|
 node.after(...nodes) 		– вставляет nodes после узла node,		|		|
 node.before(...nodes) 		– вставляет nodes перед узлом node,		|____append_____|
 node.replaceWith(...nodes) 	– вставляет nodes вместо node.			     after
	var p = document.createElement('p');					     
    	document.body.append(p);

    	var em = document.createElement('em');
    	em.append('Мир!');

    	p.append("Привет, ", em);		// вставить в параграф текстовый и обычный узлы

   	p.after(document.createElement('hr'))   // добавить элемент после <p>

 ---- document.write 
 document.write(str) 	– метод добавления текста к документу.
 document.writeln(str)  – добавляет после str символ перевода строки "\n".

 

 ==== Стили / CSS =================
 
 elem.className					- Атрибут class

 document.body.className = "class1 class2";	- устанавливает class 

    classList – это псевдо-массив

    elem.classList.contains("class") 		– возвращает true/false
	.classList.add/remove("class") 		– добавляет/удаляет класс class
	.classList.toggle("class") 		– если класса class нет, добавляет его, если есть – удаляет.
 ---------------------------------

 elem.style					- Стили в атрибуте style элемента

 background-color  => elem.style.backgroundColor
 исключение: 
	     float =>      style.cssFloat 
 префиксы:
	button.style.MozBorderRadius = '5px';
	button.style.WebkitBorderRadius = '5px';

 ---- Сброс стилей 
	elem.style.width="";

 ---- Строка стилей style.cssText	=>  все предыдущие свойства style удаляются.
	 div.style.cssText="color: red !important;	\
			    background-color: yellow; 	\
			    width: 100px; 		\
			    text-align: center; 	\
			    blabla: 5; 			\	- игнорируется
			  ";

 ---- чтение стиля из style => Полный стиль из getComputedStyle => getComputedStyle(element[, pseudo])

	var computedStyle = getComputedStyle(document.body);
    	alert( computedStyle.marginTop ); // выведет отступ в пикселях

 getComputedStyle(elem, "")	- Стиль, с учётом всего каскада, вычисленный и применённый (только чтение)
 
 // IE || другой браузер
 var computedStyle = div.currentStyle || getComputedStyle(div, '');

 ==== Размеры и прокрутка элемента ======= https://learn.javascript.ru/metrics
 
 offsetLeft/Top 		- задают смещение относительно offsetParent
 offsetWidth/Height		- Полный размер элемента: ширина/высота, включая border.
 clientLeft/Top			- Ширина левой/верхней рамки border
 clientWidth/Height		- Ширина/высота внутренней части элемента, включая содержимое и padding, 
				  не включая полосу прокрутки (если есть).
 scrollWidth/Height		- Ширина/высота внутренней части элемента, с учетом прокрутки.
 scrollLeft/Top			- Ширина/высота прокрученной области.
 
 element.style.height = element2.scrollHeight + 'px';

 ==== Размеры и прокрутка страницы ========

 document.documentElement.clientWidth/Height	- ширина/высота видимой области
						  если есть полоса прокрутки, возвращают именно
						  ширину/высоту внутри неё, доступную для документа,
 window.innerWidth/Height 			– игнорируют полосу прокрутки.


documentElement.clientWidth/Height		- Теоретически, видимая часть страницы
documentElement.scrollWidth/scrollHeight 	- полный размер с учётом прокрутки – по аналогии.

 window.pageYOffset 				- Текущая прокрутка сверху
 window.pageXOffset 				- Текущая прокрутка слева

 var scrollTop = window.pageYOffset 		-| прокрутка(чтение)
 || document.documentElement.scrollTop		 |


 ----- прокрутка(изменение) ----

 window.scrollBy(x,y)				- на x,y относительно текущей позиции.
 window.scrollTo(pageX, pageY)			- на координаты в документе.
 
 elem.scrollIntoView(true/false)		- прокрутить, чтобы elem стал видимым и 
						  оказался вверху окна(true) или внизу(false)

 document.body.style.overflow = "hidden"	- Запрет прокрутки
 document.body.style.overflow = ''		- разрешение


 ==== Координаты в окне =============================

 elem.getBoundingClientRect()			- относительно окна
						  top – Y-координата верхней границы элемента,
						  left – X-координата левой границы,
						  right – X-координата правой границы, от левого края
						  bottom – Y-координата нижней границы, от верха

     .getBoundingClientRect()			- относительно документа + прокрутка страницы

 document.elementFromPoint(clientX, clientY)	- получить элемент по координатам
 
 ==== Координаты в документе =========================

 ---- Получение координат элемента относительно

	function getCoords(elem) { 						// кроме IE8-  
		var box = elem.getBoundingClientRect();
		return { top: box.top + pageYOffset, left: box.left + pageXOffset };
	}

 ==== Координаты на экране ============================

 screenX/screenY

 screen.width 			- общая ширина/высота
 screen.height			

 screen.availWidth 		- // доступная ширина/высота (за вычетом таскбара и т.п.)
 screen.availHeight

 window.screenX			- Координаты левого-верхнего угла браузера на экране 
 window.screenY  

=============================================================================================================

==== События ================================================================================================

 ---- События мыши

 click 		– происходит, когда кликнули на элемент левой кнопкой мыши
 dblclick 	- Происходит двойной щелчок кнопкой мыши на объекте
 contextmenu 	– происходит, когда кликнули на элемент правой кнопкой мыши
 
 wheel		- движение колесика мыши
 var delta = e.deltaY || e.detail || e.wheelDelta; - количество прокрученных пикселей по горизонтали и вертикали

 mousedown	–| когда кнопку мыши нажали 
 mouseup 	 | или отжали 
 mousemove 	– Указатель мыши проходит над элементом

 mouseover 	– возникает, когда на элемент наводится мышь
		  event.target – элемент, на который пришла мышь, то есть на котором возникло событие.
		  event.relatedTarget – элемент, с которого пришла мышь.

 mouseout 	- Указатель мыши покидает элемент
		  event.target – элемент, с которого ушла мышь, то есть на котором возникло событие
		  event.relatedTarget – элемент, на который перешла мышь.

 mouseenter	~= mouseover 	но - | 1. Не учитываются переходы внутри элемента.
 mouseleave 	~= mouseout  	     | 2. События mouseenter/mouseleave не всплывают,
					  а значит с ними нельзя использовать делегирование.



 




 event.clientX	-| содержит координаты курсора относительно текущего окна
      .clientY 	 |
		 <input onmousemove="this.value = event.clientX+':'+event.clientY">

      .pageX	-| Относительно документа
      .pageY	 |


 	event.which == 1 – левая кнопка
 	event.which == 2 – средняя кнопка
 	event.which == 3 – правая кнопка

	Модификаторы shift, alt, ctrl и meta
	shiftKey	altKey		ctrlKey		metaKey (для Mac)

  		document.body.children[0].onclick = function(e) {
  		  	if (!e.altKey || !e.shiftKey) return;
    			alert( 'Ура!' );
  		}

 ---- События на элементах управления

 submit 	– посетитель отправил форму <form>
 focus 		– посетитель фокусируется на элементе, например нажимает на <input>
 reset 		- Сбрасываются данные формы

 ---- Клавиатурные события

 keydown 	– когда посетитель нажимает клавишу (включая Shift, Alt, Ctrl и Esc)
 keypress	- Нажата клавиша (исключая Shift, Alt, Ctrl и Esc)
 keyup 		– когда посетитель отпускает клавишу

	function getChar(event) {	// event.type должен быть keypress
	  	if (event.which == null) { 			// IE
    			if (event.keyCode < 32) return null; 	// спец. символ
    		return String.fromCharCode(event.keyCode)
  		}
		if (event.which != 0 && event.charCode != 0) { 	// все кроме IE
		    	if (event.which < 32) return null; 	// спец. символ
    		return String.fromCharCode(event.which); 	// остальные
  		}
		return null; 					// спец. символ
	}

 ---- События документа

 DOMContentLoaded 	– когда HTML загружен и обработан, DOM документа полностью построен и доступен
			  означает, что все DOM-элементы разметки уже созданы, можно их искать, вешать
			  обработчики, создавать интерфейс, но при этом, возможно, 
			  ещё не догрузились какие-то картинки или стили.
			  только через document.addEventListener("DOMContentLoaded", ready);
 
load 			– страница и все ресурсы загружены, 
			  используется редко, обычно нет нужды ждать этого момента.
 			  window.onload

 beforeunload/unload 	– можно проверить, сохранил ли посетитель изменения, 
			  уточнить, действительно ли он хочет покинуть страницу.
 window.onunload	- отменить сам переход нельзя
 window.onbeforeunload	- 
 ---- События CSS

 transitionend 		– когда CSS-анимация завершена
			  чтобы после анимации сделать какое-то действие или
			  объединить несколько анимаций в одну

 -----
 scroll		- происходит при прокрутке элемента

 abort 		- Загрузка изображения останавливается до ее завершения
 blur 		- Элемент теряет фокус
 change 	- Изменяется любая часть формы
 error 		- Обнаруживается ошибка JavaScript
 onload		- Объект загрузился
 resize 	- Изменяются размеры окна браузера
 scroll 	- Документ прокручивается
 select 	- Выделяется какой-нибудь текст
 unload 	- Удаляется документ

 ---- Обработчик 
 I.  Использование атрибута HTML
 	<input value="Нажми меня" onclick="alert('Клик!')" type="button">	
	<input type="button" id="button" onclick="sayThanks()" />		// c ()

 II. Использование свойства DOM-объекта
    1.	<input id="elem" type="button" value="Нажми меня" />
	<script>
	  elem.onclick = function() {
	    alert( 'Спасибо' );
	  };

 	обработчиком можно назначить и уже существующую функцию:
		function sayThanks() { alert( 'Спасибо!' ); }

		elem.onclick = sayThanks;	// без ()

	Если добавить скобки, то sayThanks() – будет уже результат выполнения функции 
	(а так как в ней нет return, то в onclick попадёт undefined). 
	Нам же нужна именно функция.
	…А вот в разметке как раз скобки нужны:

	Если обработчик надоел – его всегда можно убрать назначением 
		elem.onclick = null.

    2.	element.addEventListener("event", handler[, phase]);

	Удаление обработчика осуществляется вызовом removeEventListener:
		
		element.removeEventListener("event", handler[, phase]);


 
 Доступ к элементу через this
	Внутри обработчика события this ссылается на текущий элемент, то есть на тот, на котором он сработал.
	<button onclick="alert(this.innerHTML)">Нажми меня</button>

 ---- Свойства объекта события
	 elem.onclick = function(event) {...}

   event.type		- Тип события, в данном случае click
 	.currentTarget	- Элемент, на котором сработал обработчик. 
			  Значение – в точности такое же, как и у this, но бывают ситуации, 
			  когда обработчик является методом объекта и его this при помощи bind 
			  привязан к этому объекту, тогда мы можем использовать event.currentTarget.
 	.clientX 	-| Координаты курсора в момент клика (относительно окна)
	.clientY	 |

 ---- Всплытие и погружение

 event.target 		– это исходный элемент, на котором произошло событие, 
			  в процессе всплытия он неизменен.
 this 			–| это текущий элемент, до которого дошло всплытие,
 =event.currentTarget	 | на нём сейчас выполняется обработчик.

 event.stopPropagation()	- Прекращение всплытия
				  препятствует продвижению события дальше, но на текущем элементе
				   все обработчики отработают.
 event.stopImmediatePropagation() - Он не только предотвращает всплытие, но и останавливает
				    обработку событий на текущем элементе.

 addEventListener:
	Если аргумент true, то событие будет перехвачено по дороге вниз.
	Если аргумент false, то событие будет поймано при всплытии.

 	---------------------------------------------
	 while (target != this) {
        if (target.nodeName == 'A') {
          return handleLink(target.getAttribute('href'));
        }
        target = target.parentNode;
	--------------------------------------------

 ==== Делегирование событий 
 Алгоритм:
	1. Вешаем обработчик на контейнер.
	2. В обработчике: получаем event.target.
	3. В обработчике: если event.target или один из его родителей в контейнере 
	   (this) – интересующий нас элемент – обработать его.
 ---------------------------------------------------------------

 table.onclick = function(event) {
  var target = event.target;

  // цикл двигается вверх от target к родителям до table
  while (target != table) {
    if (target.tagName == 'TD') {	// нашли элемент, который нас интересует!
      highlight(target);
      return;
    }
    target = target.parentNode;
  }
 }
 ------------------------------------------------
 table.onclick = function(event) {
  var target = event.target;

  var td = target.closest('td');
  if (!td) return; // клик вне <td>, не интересует

  // если клик на td, но вне этой таблицы (возможно при вложенных таблицах)
  // то не интересует
  if (!table.contains(td)) return;

  // нашли элемент, который нас интересует!
  highlight(td);
 }
 ------------------------------------------------
 Применение делегирования: действия в разметке

   function Menu(elem) {
    this.save = function() {
      alert( 'сохраняю' );
    };
    this.load = function() {
      alert( 'загружаю' );
    };
    this.search = function() {
      alert( 'ищу' );
    };

    var self = this;

    elem.onclick = function(e) {
      var target = e.target;
      var action = target.getAttribute('data-action');
      if (action) {
        self[action]();
      }
    };
  }

  new Menu(menu);
 --------------------------------------------------
 ==== Приём проектирования "поведение"
	1. Элементу ставится атрибут, описывающий его поведение.
	2. При помощи делегирования ставится обработчик на документ, который ловит все клики и, 
	   если элемент имеет нужный атрибут, производит нужное действие.
 ---------------------------------------
 <button data-counter>2</button>
 <script>
  document.onclick = function(event) {
    if (!event.target.hasAttribute('data-counter')) return;
    var counter = event.target;
    counter.innerHTML++;
  };
 ----------------------------------------
 ==== Отмена действия браузера

	1. event.preventDefault()
	2. Если onсобытие (не через addEventListener), то можно просто вернуть false из обработчика.
	   <a href="/" onclick="return false">Нажми здесь</a>

 ==== Генерация событий на элементах
 
 ---- Конструктор Event
 var event = new Event(тип события[, флаги]);
	Тип события 	– может быть как своим, так и встроенным, к примеру "click".
	Флаги 		– объект вида { bubbles: true/false, cancelable: true/false }, 
			  bubbles указывает, всплывает ли событие
			  cancelable – можно ли отменить действие по умолчанию.
			  по умолчанию: {bubbles: false, cancelable: false}.

 ---- Метод dispatchEvent
 Затем, чтобы инициировать событие, запускается elem.dispatchEvent(event).
 ---------------------------------------------------------------------------------------
 ==== отмена выделения, невыделяемые элементы 

 I.----  отмена mousedown/selectstart
	 onselectstart="return false" onmousedown="return false"		
		
 II.---  снятие выделения пост-фактум
	 ondblclick="clearSelection()"

  		function clearSelection() {
  		  if (window.getSelection) {
   			window.getSelection().removeAllRanges();
    		  } else { // старый IE
			document.selection.empty();
    		  }
  		}
 III.--  свойство user-select
 	<style>	b {
    		   -webkit-user-select: none;	/* user-select -- это нестандартное свойство */
    		   -moz-user-select: none;	/* поэтому нужны префиксы */
		   -ms-user-select: none;
		}
	</style>
	<b>Этот текст нельзя выделить (кроме IE9-)</b>

 ---- Запрет копирования 
      oncopy="return false"
--------------------------------------------------------------
 ==== Мышь: Drag'n'Drop
 
	var ball = document.getElementById('ball');

	ball.onmousedown = function(e) {	// 1. отследить нажатие

	  var coords = getCoords(ball);
	  var shiftX = e.pageX - coords.left;
	  var shiftY = e.pageY - coords.top;
 	
  // подготовить к перемещению
  // 2. разместить на том же месте, но в абсолютных координатах

	  ball.style.position = 'absolute';
	  document.body.appendChild(ball);	// переместим в body, чтобы мяч был точно не внутри position:relative
	  moveAt(e);

	  ball.style.zIndex = 1000; // показывать мяч над другими элементами

  // передвинуть мяч под координаты курсора
  // и сдвинуть на половину ширины/высоты для центрирования
	  function moveAt(e) {
	    ball.style.left = e.pageX - shiftX + 'px';
	    ball.style.top = e.pageY - shiftY + 'px';
	  }

  // 3. перемещать по экрану	
	  document.onmousemove = function(e) {
	    moveAt(e);
	  };
  
	  ball.onmouseup = function() {
	    document.onmousemove = null;
	    ball.onmouseup = null;
	  };
	
	}
	
	ball.ondragstart = function() {
	  return false;
	};
	
============================================================================================================
==== Формы === https://learn.javascript.ru/form-elements ===================================================
 ---- навигации по формам
 document.forms.my 		- форма с именем 'my'		<form name="my">
 document.forms[0] 		- первая форма в документе

 form.elements.one;		- Элемент формы с именем "one" <input name="one">
			  	  если name="one" > 1, вернет коллекцию
 form.one			- так тоже можно, но есть косяк

 form.one.name = "new-name";	- меняем name, теперь вместо name="one" исп-ся name="new-name";


 form.elements.set.elements.text 	- fieldset тоже имеет elements (set = fieldset?)

 element.form			- Ссылка на форму от ребенка

 ---- select
 I.	select.value
 II.	select.selectedIndex
		select.selectedIndex = 0; 	// первая опция
		      .selectedIndex = -1 	// очистит выбор. 
 -----------
 select.options			- Список элементов-опций 
	Если select допускает множественный выбор (атрибут multiple), 
	то значения можно получить/установить, сделав цикл по select.options. 
	При этом выбранные опции будут иметь свойство option.selected = true.

	for (var i = 0; i < select.options.length; i++) {
		var option = select.options[i];
		if(option.selected) { alert( option.value ); }
	}
 свойства option
		selected	- выбрана ли опция
		index		- номер опции в списке селекта
		text		- Текстовое содержимое опции (то, что видит посетитель).
 --------------------
  ---- new Option ---
 
  option = new Option(text, value, defaultSelected, selected);
	text – содержимое,	value – значение,
	defaultSelected и selected поставьте в true, чтобы сделать элемент выбранным.

	Его можно использовать вместо document.createElement('option'), например:
	var option = new Option("Текст", "value");	// создаст <option value="value">Текст</option>
	var option = new Option("Текст", "value", true, true);

 ==== События формы 
 focus 		- когда пользователь фокусируется на элементе
 blur 		– когда фокус исчезает, например посетитель кликает на другом месте экрана.
 События focus и blur не всплывают (не можем использовать делегирование ).
 Это забавно, но хотя focus/blur не всплывают, они могут быть пойманы на фазе перехвата.

 Методы focus/blur
 Методы с теми же названиями переводят/уводят фокус с элемента.

 События focusin/focusout – то же самое, что и focus/blur, только они всплывают.
	Не поддерживаются Firefox (хотя поддерживаются даже старейшими IE)
	Должны быть назначены не через on-свойство, а при помощи elem.addEventListener.

 change 	- происходит по окончании изменении значения элемента формы,
		  когда это изменение зафиксировано.
		  Для текстовых элементов это означает, 
		  что событие произойдёт не при каждом вводе, а при потере фокуса.
		  Для остальных же элементов: select, input type=checkbox/radio 
		  оно срабатывает сразу при выборе значения.

 input 		- срабатывает тут же при изменении значения текстового элемента (IE8-).
 
 cut, copy, paste - Эти события используются редко. 
		    Они происходят при вырезании/вставке/копировании значения.




 ====
 document.activeElement 	текущий элемент, на котором фокус

 
---- Черновик --------------------------------------------------------------------
 if (input.checked) { alert( "Чекбокс выбран" ); }
=============================================================================================================
==== BOM ====================================================================================================
 location.href 		- выведет текущий адрес
 navigator.userAgent 	- содержит информацию о браузере
 navigator.platform 	- содержит информацию о платформе
 
=============================================================================================================
==== window. 	Окна и  Фреймы ==============================================================================
 window.open('http://ya.ru');			- открытие нового окна
 win = window.open(url, name, params)		[ https://learn.javascript.ru/window-methods ]+
var newWin = window.open("about:blank", "hello", "width=200,height=200");newWin.document.write("Привет, мир!");
 params:
 1. Настройки расположения окна: 
	left/top (число)
	width/height (число)
 2. Свойства окна:
	menubar (yes/no)	- Скрыть или показать строку меню браузера.
	toolbar (yes/no)	
	location (yes/no)
	status (yes/no)
	resizable (yes/no)
	scrollbars (yes/no)
 
 Новое окно имеет ссылку на родительское в window.opener.

 --- События
 Наиболее важные события при работе с окном браузера:

 onresize – событие изменения размера окна.
 onscroll – событие при прокрутке окна.
 onload – полностью загрузилась страница со всеми ресурсами.
 onfocus/onblur – получение/потеря фокуса.

 ---- Методы и свойства

 window.closed	- Свойство window.closed равно true, если окно закрыто. Может быть использовано, чтобы
		  проверить, закрыл ли посетитель попап.
 window.close() - Закрывает попап без предупреждений и уведомлений. Вообще, метод close() можно вызвать для
		  любого окна, в том числе, текущего. Но если окно открыто не с помощью window.open(), то
		  браузер может проигнорировать вызов close или запросить подтверждение.

 ---- Перемещение и изменение размеров окна

 win.moveBy(x,y) 	    - Перемещает окно относительно текущего положения на x пикселей вправо и y пикселей
			      вниз. Допускаются отрицательные значения.
 win.moveTo(x,y)	    - Передвигает окно в заданную координатами x и y точку экрана монитора.
 win.resizeBy(width,height) - Изменяет размер окна на заданную величину width/height (ширина/высота).
			      Допускаются отрицательные значения.
 win.resizeTo(width,height) - Изменяет размер окна на заданное значение.

 ---- Прокрутка окна

 win.scrollBy(x,y)		- Прокрутка окна на заданное число пикселей вперед или назад. 
				  Допускаются отрицательные значения.
 win.scrollTo(x,y)		- Прокручивает окно к заданным координатам.
 elem.scrollIntoView(top)	- Этот метод прокрутки вызывается на элементе. При этом окно прокручивается
				  так, чтобы элемент был полностью видим. Если параметр top равен true или не
				  задан, то верх элемента совпадает с верхом окна. Если он равен false, то
 				  окно прокручивается так, чтобы нижний край элемента совпал с нижним краем
				  окна.

 ---- Общение между окнами и фреймами

 I.	iframe.contentWindow
 	iframe.contentWindow.document 
 	iframe.contentWindow.document.body
 II.	window.frames[0] 		– доступ по номеру.
	window.frames.iframeName 	– доступ по name ифрейма.

 <iframe sandbox> – наложить дополнительные ограничения:
	- Заставляет браузер считать ифрейм загруженным с другого источника, так что он и внешнее окно больше 
	  не могут обращаться к переменным друг друга.
	- Отключает формы и скрипты в ифрейме.
	- Запрещает менять parent.location из ифрейма.

 allow-same-origin 	- Браузер будет считать документ в ифрейме пришедшим с другого домена и накладывать
			  соответствующие ограничения на работу с ним. 
			  Если ифрейм и так с другого домена, то ничего не меняется.
 allow-top-navigation	- Разрешает ифрейму менять parent.location.
 allow-forms		- Разрешает отправлять формы из iframe.
 allow-scripts		- Разрешает выполнение скриптов из ифрейма.
			  Но скриптам, всё же, будет запрещено открывать попапы.

 ---- Общение окон с разных доменов: postMessage
 
 ---- ---- Отправитель: метод postMessage

 	если мы хотим отправить сообщение в окно win, 
	то нужно вызвать win.postMessage(data, targetOrigin).
		data		- Данные. По спецификации, это может быть любой объект,
				  который будет клонирован с сохранением структуры при передаче.
		targetOrigin	- Разрешить получение сообщения только окнам с данного источника.
				  При указании '*' ограничений нет.

	<iframe src="http://target.com" name="target">
	<script>
	  var win = window.frames.target;
	  win.postMessage("сообщение", "http://javascript.ru");
	</script>

 ---- ---- Получатель: событие onmessage
	
	Чтобы получить сообщение, окно должно поставить обработчик на событие onmessage.

	Свойства объекта события:
		data	- Присланные данные
		origin	- Источник, из которого пришло сообщение, 
			  например http://javascript.ru.
		source	- Ссылка на окно, с которого пришло сообщение. Можно тут же ответить.
			  
 Назначать обработчик нужно обязательно через методы addEventListener/attachEvent, например:

	function listener(event) {
	  if (event.origin != 'http://javascript.ru') {
	    // что-то прислали с неизвестного домена - проигнорируем..
	    return;
	  }
	
	  alert( "получено: " + event.data );
	}
	
	if (window.addEventListener) {
	  window.addEventListener("message", listener);
	} else {
	  // IE8
	  window.attachEvent("onmessage", listener);
	}


 ---- Привлечение внимания к окну	// Перечитать смысл не понял
 window.focus()		- позволяет сфокусироваться на окне

 ---- 
=============================================================================================================
==== window.свойства объекта ================================================================================

 .closed 	- Возвращает булево значение, показывающее, было ли закрыто окно
 .defaultStatus	- Устанавливает или возвращает исходный текст панели состояния окна
 .document 	- Возвращает объект документа для окна
 .frames 	- Возвращает массив, состоящий из всех фреймов и i-фреймов окна
 .history 	- Возвращает для окна объект истории
 .innerHeight 	- Устанавливает или возвращает внутреннюю высоту области содержимого окна
 .innerWidth 	- Устанавливает или возвращает внутреннюю ширину области содержимого окна
 .length 	- Возвращает количество фреймов и i-фреймов окна
 .location 	- Возвращает местоположение объекта в окне
 .name 		- Устанавливает или возвращает имя окна
 .navigator 	- Возвращает для окна объект-навигатор
 .opener 	- Возвращает ссылку на то окно, из которого было создано данное окно
 .outerHeight 	- Устанав. или возвращает внешнюю высоту окна, включая панель инструментов и полосу прокрутки
 .outerWidth 	- --	      возвращает внешнюю ширину окна, включая панель инстру ментов и полосу прокрутки
 .pageXOffset 	- количество пикселов, на которое был горизонтально прокручен документ от левого края окна
 .pageYOffset 	- количество пикселов, на которое был вертикально прокручен документ от верхнего края окна
 .parent 	- Возвращает для окна объект родительского окна
 .screen 	- Возвращает для окна объект экрана
 .screenLeft 	- Возвращает координату x окна относительно экрана во всех последних браузерах, кроме Mozilla 
		  Firefox (для которого нужно использовать screenX)
 .screenTop 	-  - координату y, кроме Mozilla Firefox (screenY)
 .screenX 	- Возвращает координату x окна относительно экрана во всех последних браузерах, кроме Opera,
		  который возвращает неправильное значение; не поддерживается в версиях Internet Explorer,
		  предшествующих 9-й версииВстроенный JavaScript
 .screenY 	- Возвращает координату y ... 
 .self 		- Возвращает the current window
 .status 	- Устанавливает или возвращает текст на панели состояния окна
 .top 		- Возвращает верхнее окно браузера	
=============================================================================================================

=============================================================================================================
---- Доступ к CSS ---------
 --- библиотека ----
 function O(obj) { if (typeof obj == 'object') return obj; else return document.getElementById(obj); }
 |-	O('myobj').style.color = 'green'; 
 function S(obj) { return O(obj).style; }
 |-	S('myobj').color = 'green';
 function C(name) { var elements = document.getElementsByTagName('*'); var objects = [];
		    for (var i = 0 ;  i < elements.length ; ++i) 
			if (elements[i].className == name) objects.push(elements[i]);
 return objects; }
 |-	myarray = C('myclass')
	for (i = 0 ; i < myarray.length ; ++i)
		S(myarray[i]).textDecoration = 'underline';
===============================================================================================================

---- Canvas -----------------------
 | функции O, S, C взять из библиотеки с вверху
 ---- японский флаг ---------
 canvas = O('mycanvas');				// ссылка на id из html-файла
 context = canvas.getContext('2d');			// запрашивает двумерный доступ к холсту
 context.fillStyle = 'red';				// 
 S(canvas).border = '1px solid black';
 context.beginPath();					// открыть путь контента
 context.moveTo(160, 120);				// переместится к точке с координатами
 context.arc(160, 120, 70, 0, Math.PI * 2, false);	// 70 - радиус, 0 - начало угла (градусы)
							// Math.PI * 2 - длина окружности
							// false - по часовой стрелке, true - против
 context.closePath();					// закрываем путь
 context.fill();					// осуществляем заливку
 -----------------

 O('myimage').src = canvas.toDataURL();			// копирование изоб-я с канваса в элемент с  id='myimage'
 O('myimage').src = canvas.toDataURL('image/jpeg', 0.4) // 0,4 - степень сжатия

  context.fillStyle = 'blue';		// заливка
 --- прямоугольник ----
 context.fillRect(20, 20, 600, 200);	// 20,20 - нач. коорд., 600 - ширина, 200 - высота.
 ----
 context.clearRect(40, 40, 560, 160);	// прозрачный прямоугольник
 ----
 context.strokeStyle = 'green';		// цвет обводки
 context.strokeRect(60, 60, 20, 60);	// контур прямоугольника
 --------------
 
 


===============================================================================================================

---- Аудио -----------
 function playaudio() { O('myaudio').play() }

 function pauseaudio() { O('myaudio').pause() }

===============================================================================================================

---- Видео -----------
 function playvideo() { O('myvideo').play() }

 function pausevideo() { O('myvideo').pause() }
 
===============================================================================================================
==== Геолокация ====


289 [2]
---- Пример I. ---------
 
<script src="https://maps.googleapis.com/maps/api/js?sensor=false"></script>

 ---- html --------
 <div id='status'></div>
 <div id='map'></div>
 ------------------
 if (typeof navigator.geolocation == 'undefined')
	alert("Геолокация не поддерживается.")
else navigator.geolocation.getCurrentPosition(granted, denied);


function granted(position) {
	O('status').innerHTML = 'Разрешение дано';
	S('map').border = '1px solid black';
	S('map').width = '640px';
	S('map').height = '320px';
	var lat = position.coords.latitude;
	var long = position.coords.longitude;
	var gmap = O('map');
	var gopts = { 
		center: new google.maps.LatLng(lat, long), 
		zoom: 9, 
		mapTypeId: google.maps.MapTypeId.ROADMAP	// ROADMAP - тип карты 
								// SATELLITE  - изображение, полученное со спутника
								// HYBRID
		};
	var map = new google.maps.Map(gmap, gopts);
}

function denied(error) {
	var message;

	switch(error.code) {
		case 1: message = 'Доступ запрещен'; 			break;
		case 2: message = 'Позиция недоступна'; 		break;
		case 3: message = 'Время ожидания операции истекло'; 	break;
		case 4: message = 'Неизвестная ошибка'; 		break;
	}

	O('status').innerHTML = message;
}

---- Пример II. ------------------ [2]
<section id="location">
			<button id="getlocation">Узнать мое местоположение</button>
</section>
function initiate(){
	var get = document.getElementById('getlocation');
	get.addEventListener('click', getlocation, false);
}
 
function getlocation(){
	navigator.geolocation.getCurrentPosition(showinfo);
}

function showinfo(position) {
	var location = document.getElementById('location');
	var data = "";
	data += 'Широта: ' + position.coords.latitude + "<br>";
	data += 'Долгота: ' + position.coords.longitude + "<br>";
	data += 'Точность: ' + position.coords.accuracy + "mts.<br>";
	location.innerHTML = data;
}
window.addEventListener('load', initiate, false);
 =====================================
===============================================================================================================

---- Локальное хранилище ---------- Никсон [593] не понял перечитать еще раз
if (typeof localStorage == 'undefined') {
	alert("Local storage is not available");
}
else {
	username = localStorage.getItem('username');
	password = localStorage.getItem('password');
	alert("The current values of 'username' and 'password' are\n\n" + username + " / " + password + "\n\nClick OK to assign values");
	
	localStorage.setItem('username', 'ceastwood');
	localStorage.setItem('password', 'makemyday');
	username = localStorage.getItem('username');
	password = localStorage.getItem('password');
	alert("The current values of 'username' and 'password' are\n\n" + username + " / " + password + "\n\nClick OK to clear values");

	localStorage.removeItem('username');
	localStorage.removeItem('password');
	username = localStorage.getItem('username');
	password = localStorage.getItem('password');
	alert("The current values of 'username' and 'password' are\n\n" + username + " / " + password);
}

===============================================================================================================

---- Рабочие веб-процессы ---------

===============================================================================================================

----Автономные веб-приложения -----
 -- clock.appcache
	CACHE MANIFEST
	clock.html
	OSC.js
	clock.css
	clock.js
 -- clock.html
	<html manifest='clock.appcache'>
	<p>Текущее время: <output id='clock'></output></p>

 -- .htaccess 
	AddType text/cache-manifest .appcache
 -- clock.js
	setInterval(function() { O('clock').innerHTML = new Date(); }, 1000)
 -- clock.css
	output { font-weight:bold; }
===============================================================================================================

---- Перетаскивание ------------------ Никсон [600]
 ondragover 'allow(event)'
 ondrop ='drop(event)'
 ondragstart='drag(event)'
 draggable='true'

 ondragenter
 ondragleavefor
 ondragendfor
===============================================================================================================
 
---- Обмен сообщениями между документами -----


===============================================================================================================

onclick="window.location.reload(true)" 	- Перезагрузить ифрейм


   _   _
  (q\_/p)
   /. .\
  =\_t_/=   __
   /   \   (
  ((   ))   )
  /\) (/\  /
  \  Y  /-'
   nn^nn

==== Анимация =======================================================================================
 var start = Date.now(); // сохранить время начала

 var timer = setInterval(function() {
  
  var timePassed = Date.now() - start;	// вычислить сколько времени прошло с начала анимации

  if (timePassed >= 2000) {
    clearInterval(timer); 		// конец через 2 секунды
    return;
  }

  draw(timePassed);			// рисует состояние анимации, соответствующее времени timePassed

 }, 20);

 function draw(timePassed) {			// в то время как timePassed идёт от 0 до 2000
   train.style.left = timePassed / 5 + 'px';	// left принимает значения от 0 до 400px
 }

 ---- группировать все перерисовки в одну и запускать их централизованно, все вместе
 setInterval(function() {
  /* отрисовать все анимации */
 }, 20);
 ---------------------
 var requestId = requestAnimationFrame(callback)

 -----
 <script>
  var prev = performance.now();
  var times = 0;

  requestAnimationFrame(function measure(time) {
    document.body.insertAdjacentHTML("beforeEnd", Math.floor(time - prev) + " ");
    prev = time;

    if (times++ < 10) requestAnimationFrame(measure);
  })
</script>
 ----

 ---- Функция анимации на основе requestAnimationFrame:
 
 function animate(draw, duration) {			// Рисует функция draw
  var start = performance.now();			// Продолжительность анимации duration

  requestAnimationFrame(function animate(time) {
   
    var timePassed = time - start; 			// определить, сколько прошло времени 
							// с начала анимации
    if (timePassed > duration) timePassed = duration;	// возможно небольшое превышение времени, 
							// в этом случае зафиксировать конец
    draw(timePassed); 					// нарисовать состояние анимации в момент timePassed

   
    if (timePassed < duration) { 			// если время анимации 
							// не закончилось - запланировать ещё кадр
      requestAnimationFrame(animate);
    }
  });
 }
 --------------------

======================================================================================================
==== Стоян Стефанов - Шаблоны ========================================================================
======================================================================================================
==== Es15 ====
<script src="https://js.cx/babel-core/browser.min.js"></script>
<script type="text/babel">
 "use strict";
    ...
</script>
-------------
 let:	Видны только после объявления и только в текущем блоке.
	Нельзя переобъявлять (в том же блоке).
	При объявлении переменной в цикле for(let …) – она видна только в этом цикле.
	  Причём каждой итерации соответствует своя переменная let.

 const:	это константа, в остальном – как let.

 ---- Деструктуризация: - разбивать объект или массив на переменные при присвоении.

 let [firstName, lastName] = ["Илья", "Кантор"];

 let [, , title] = "Юлий Цезарь Император Рима".split(" ");
 alert(title); 		// Император
 
 ~~~~ ... (spread)
 let [firstName, lastName, ...rest] = "Юлий Цезарь Император Рима".split(" ");

 alert(firstName); 	// Юлий
 alert(lastName);  	// Цезарь
 alert(rest); 		// Император,Рима (массив из 2х элементов)

 ~~~~ Деструктуризация объекта
 let options = {
  title: "Меню",
  width: 100,
  height: 200
 };

 let {title, width, height} = options;

 alert(title);  // Меню
 alert(width);  // 100
 alert(height); // 200

 let {width: w, height: h, title} = options;

 alert(title);  // Меню
 alert(w);      // 100
 alert(h);      // 200

 ---- Функции:
 let inc = x => x+1;
 let inc = function(x) { return x + 1; };

 let sum = (a,b) => { a + b; ...;}

 ---- Строки:
 ``	- обратные кавычки
 	В них разрешён перевод строки.
	Можно вставлять выражения при помощи ${…}.
 let apples = 2;
 let oranges = 3;

 alert(`${apples} + ${oranges} = ${apples + oranges}`); // 2 + 3 = 5

 str.includes(s)	– проверяет, включает ли одна строка в себя другую, возвращает true/false.
 str.endsWith(s) 	– возвращает true, если строка str заканчивается подстрокой s.
 str.startsWith(s) 	– возвращает true, если строка str начинается со строки s.
 str.repeat(times) 	– повторяет строку str times раз.

 ---- Классы:
-- примеры объявления классов
class Dog { ... }
const Dog = class { ... }
function Dog(name) { this.name = name; }
--

class User {

  constructor(name) {
    this.name = name;
  }							// без знака препинания

  sayHi() { alert(this.name); }
  
  static info() { ... }	// доступен только при вызове User.info();

  get description() { ... } 

  set nicknames(value) { this.nick = value.trim(); }
  get nicknames() { return this.nick; }

}

let user = new User("Вася");
user.sayHi(); 		// Вася
user.info();  		// error
User.info();		// ... без ошибки User c большой буквы
user.description	// ... 


 == Set == множества == 

 let people = new Set()
 
  people.add(...)
	   	.size()
		.clear()
		.values()	-> SetIterator{}
		.keys()		-> SetIterator{..., ...}
		.entries()	-> SetIterator{[..., ...], [..., ...]}
		.has(...)	-> borlean
		
 ==============
 == Map ==
 new Map
 =========
==== Литература ====
1. Илья Кантор
2. Гоше: HTML5. Для профессионалов
====================

==== audio ==== 
 html: <audio src="sounds/tink.wav" data-key="76"></audio>

  let audio = document.querySelector(`audio[data-key="${e.keyCode}"]`);
  if(!audio) return;
  audio.currentTime = 0; // перемотка к началу
  audio.play();
=============
=== js30 ==
-- 1. drum kit --
html
 <audio data-key="65" src="sounds/clap.wav"></audio>
js
  function playSound(e) {
    const audio = document.querySelector(`audio[data-key="${e.keyCode}"]`);
    const key = document.querySelector(`div[data-key="${e.keyCode}"]`);
    if (!audio) return;
    key.classList.add('playing');
    audio.currentTime = 0;
    audio.play();
  }
-----------------
-- 2. Clock -----
  function setDate() {
    const now = new Date();
    const seconds = now.getSeconds();
    const secondsDegrees = ((seconds / 60) * 360) + 90;
    secondHand.style.transform = `rotate(${secondsDegrees}deg)`;

	... mins ... hour ... 
  }
-----------------
-- 3. Variables --
html 
 <input id="spacing" type="range" name="spacing" min="10" max="200" value="10" data-sizing="px">
css
 :root { --spacing: 10px; }
js
 function handleUpdate() {
      const suffix = this.dataset.sizing || '';
      document.documentElement.style.setProperty(`--${this.name}`, this.value + suffix);
    }
------------------
-- 4. Array ------
const inventors = [ { first: 'Albert', last: 'Einstein', year: 1879, passed: 1955 }, ... ]

const fifteen 	= inventors.filter	(inventor => (inventor.year >= 1500 && inventor.year < 1600));
const fullNames = inventors.map		(inventor => `${inventor.first} ${inventor.last}`);
const ordered 	= inventors.sort	((a, b) => a.year > b.year ? 1 : -1);

const totalYears = inventors.reduce((total, inventor) => {
      return total + (inventor.passed - inventor.year);
    }, 0);

 const oldest = inventors.sort(function(a, b) {
      const lastInventor = a.passed - a.year;
      const nextInventor = b.passed - b.year;
      return lastInventor > nextInventor ? -1 : 1;
    });
------------------
-- 5. Flex Panel Gallery --
 .panel { flex: 1;  ... }

__js 
 //..
	if (e.propertyName.includes('flex')) {
        this.classList.toggle('open-active');
    }
 //..
 panels.forEach(panel => panel.addEventListener('click', toggleOpen));
 panels.forEach(panel => panel.addEventListener('transitionend', toggleActive));
---------------------------
-- 6.Type Ahead --
 const endpoint = 'json.json'
 const cities = [];
 fetch(endpoint)
  .then(blob => blob.json())
  .then(data => cities.push(...data));

 function displayMatches() {
	// поиск совпадений +regexp +...
 }
 //..
 searchInput.addEventListener('change', displayMatches);
 searchInput.addEventListener('keyup', displayMatches);
------------------
-- 7. Array Cardio --
 const people 	= [ { name: 'Wes', year: 1988 }, ... ];
 const comments = [ { text: 'Love this!', id: 523423 }, ... ];
 
 -- .some()
	// is at least one person 19?
    const isAdult = people.some(function(person) {
    	const currentYear = (new Date()).getFullYear();
    	if(currentYear - person.year >= 19) { return true; }   
	});
	// or 
	const isAdult = people.some(person => ((new Date()).getFullYear()) - person.year >= 19);

	-- .every()
	const allAdults = people.every(person => ((new Date()).getFullYear()) - person.year >= 19);
    console.log({allAdults});

	-- .find()
	const comment = comments.find(comment => comment.id === 823423);

	-- .findIndex()
	const index = comments.findIndex(comment => comment.id === 823423);

	-- .splice(index, 1);
    const newComments = [
      ...comments.slice(0, index),
      ...comments.slice(index + 1)
    ];

-- 8. Canvas -----
canvas.addEventListener('mousedown', (e) => {
  isDrawing = true;
  [lastX, lastY] = [e.offsetX, e.offsetY];
});
canvas.addEventListener('mousemove', draw);
canvas.addEventListener('mouseup', () => isDrawing = false);
canvas.addEventListener('mouseout', () => isDrawing = false);


-- 9. Dev Tools --
 
 console.
	.log('Hello I am a %s string!', '💩');
    .warn('OH NOOO');
    .error('Shit!');
    .info('Crocodiles eat 3-4 people per year');
	.assert(p.classList.contains('ouch'), 'That is wrong!');
    .clear();

 dogs.forEach(dog => {
      console.groupCollapsed(`${dog.name}`);
      console.log(`This is ${dog.name}`);
      console.log(`${dog.name} is ${dog.age} years old`);
      console.log(`${dog.name} is ${dog.age * 7} dog years old`);
      console.groupEnd(`${dog.name}`);


    console.count('Wes');		-> ... 1
    console.count('Wes');		-> ... 2
    console.count('Steve');		-> ... 1
    console.count('Steve');		-> ... 2
    console.count('Wes');		-> ... 3

 console.time('fetching data');
    fetch('https://api.github.com/users/wesbos')
      .then(data => data.json())
      .then(data => {
        console.timeEnd('fetching data');
        console.log(data);
      });
 console.table(dogs);
------------------
-- 10. Checkboxes: Hold Shift and Check --


------------------------------------------
------------------
------------------
------------------
------------------
------------------
------------------
------------------
------------------
------------------
------------------
------------------
------------------
------------------
------------------
------------------
------------------
------------------
------------------
------------------
------------------
------------------
------------------
------------------
------------------

===========
==== шаблоны == patterns ==
 ---- for in --
var man = {...}
for (var i in man) {
	if (Object.prototype.hasOwnProperty.call(man, i)) { // фильтрация
		console.log(i, ":", man[i]);
	}
}

--------------

---- создание свойств объектов -- .module = {} --
  -- проверка, не существовал ли раньше это св-во

var MYAPP = MYAPP || {};

MYAPP.namespace = function(ns_string) {
    var parts = ns_string.split('.'),
        parent = MYAPP;

    if (parts[0] === "MYAPP") {
        parts = parts.slice(1);
    }

    for (var i = 0; i < parts.length; i++) {
        if (typeof parent[parts[i]] === 'undefined') {
            parent[parts[i]] = {};
        }
        parent = parent[parts[i]];
    }

    return parent;
};

var module2 = MYAPP.namespace('MYAPP.modules.module2');

--------------------------------------------------


===========================


==== «Паттерны для масштабируемых JavaScript-приложений» от Эдди Османи ====

Архитектура: модуль, фасад и медиатор
============================================================================

